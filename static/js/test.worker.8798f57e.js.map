{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../ssim/webpack/universalModuleDefinition","../ssim/src/bezkrovnySsim.ts","../ssim/src/defaults.ts","../ssim/src/downsample.ts","../ssim/src/index.ts","../ssim/src/math.ts","../ssim/src/matlab/conv2.ts","../ssim/src/matlab/filter2.ts","../ssim/src/matlab/fspecial.ts","../ssim/src/matlab/imfilter.ts","../ssim/src/matlab/index.ts","../ssim/src/matlab/internal/numbers.ts","../ssim/src/matlab/mod.ts","../ssim/src/matlab/normpdf.ts","../ssim/src/matlab/ones.ts","../ssim/src/matlab/padarray.ts","../ssim/src/matlab/rgb2gray.ts","../ssim/src/matlab/skip2d.ts","../ssim/src/matlab/sub.ts","../ssim/src/matlab/transpose.ts","../ssim/src/matlab/zeros.ts","../ssim/src/originalSsim.ts","../ssim/src/ssim.ts","../ssim/src/weberSsim.ts","../ssim/webpack/bootstrap","../ssim/webpack/startup","../node_modules/pixelmatch/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/nonIterableSpread.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","common/geometry.ts","common/ga.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","test.worker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","arr","len","length","arr2","Array","self","windowSsim","values1","values2","bitDepth","k1","k2","L","c1","c2","average1","a","average","average2","σSqx","variance","σSqy","covariance","pixels1","pixels2","options","width","Math","ceil","windowSize","height","data","counter","y","x","windowWidth","min","windowHeight","sub","defaults","downsample","ssim","maxSize","rgb2grayVersion","imageDownsample","pixels","filter","f","imdown","imfilter","skip2d","factor","round","lpf","ones","divide2d","sum2d","ssimTargets","fast","original","originalSsim","bezkrovny","bezkrovnySsim","weber","weberSsim","getOptions","userOptions","keys","forEach","option","Error","join","image1","image2","start","Date","getTime","ssimMap","rgb2gray","rgb2grayInteger","mssim","mean2d","ssim_map","performance","xn","sum","out","add2dScalar","increase","ref","multiply2d","A","multiplier","ref1","ref2","e","floor","offset","decrease","divisor","values","avg","varx","cov","mxConv2","b","shape","refWidth","refHeight","cWidth","cHeight","zeros","r1","br1c1","j","reshape","boxConv","convn","isBoxKernel","expected","b1","b2","mb","max","nb","temp","ma","na","rowStart","colStart","args","h","X","conv2","_type","hsize","σ","gauss","exp","size","total","pad","resSize","frows","fcols","padarray","mod","slice","push","filter2","num","µ","z","numbers","_padval","_direction","padHeight","padWidth","abs","mirrored","B","concat","uint8Array","Uint8Array","from","array","startRow","everyRow","endRow","startCol","everyCol","endCol","Ai","Aj","w","fspecial","μ1","μ2","μ1Sq","square2d","μ2Sq","μ12","pixels1Sq","pixels2Sq","σ1Sq","subtract2d","σ2Sq","σ12","num1","add2d","num2","denom1","denom2","numerator1","numerator2","denominator1","denominator2","normpdf","wt","transpose","edgeHandler","sumArray","matrixWidth","rightEdge","bottomEdge","bottomRightEdge","partialSumMatrix1","matrixHeight","Int32Array","partialSumMatrix2","data1","data2","windowMatrix","sumMatrix","imageWidth","imageHeight","windows","windowSums","windowVariance","sums","windowSquared","varX","v","mean","sumSquares","squareMeans","windowCovariance","sums1","sums2","covXY","pixels1Rounded","pixels2Rounded","variance1","variance2","ssims","meanx","meany","vary","__webpack_module_cache__","__webpack_modules__","img1","img2","output","isPixelData","assign","defaultOptions","a32","Uint32Array","buffer","byteOffset","b32","identical","diffMask","drawGrayPixel","alpha","maxDelta","threshold","diff","pos","delta","colorDelta","includeAA","antialiased","drawPixel","diffColorAlt","diffColor","aaColor","ArrayBuffer","isView","constructor","BYTES_PER_ELEMENT","img","x1","y1","minX","minY","maxX","maxY","x0","y0","x2","y2","zeroes","hasManySiblings","pos2","k","yOnly","g1","a1","r2","g2","a2","blend","rgb2y","rgb2i","q","rgb2q","g","val","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","arrayLikeToArray","isArray","iter","iterator","minLen","toString","test","TypeError","_arrayLikeToArray","_unsupportedIterableToArray","_toConsumableArray","getRGBAFromColor","drawPolygon","ctx","polygon","vertices","fillStyle","color","beginPath","vertex","moveTo","lineTo","closePath","fill","moveVertex","range","direction","random","PI","distance","cos","sin","createIndividual","nbPolygons","nbVertices","nbColor","genes","randomNumberInRange","id","now","fitness","pixelDiff","undefined","probability","phenotype","isInteger","convertFitnessIntoProbabilities","population","sumFit","scores","populationWithProba","allowArrayLike","it","F","done","_e","err","normalCompletion","didErr","step","next","_e2","ind","previousProba","pickParent","rand","pickParentFromTournament","tournamentSize","best","candidate","crossOver","parentRatio","child","probaToPickFromA","polygonSize","evaluate","enableSsim","enablePixelDiff","ratioSsim","ratioPixelDiff","image","nbCoordinates","buildPhenotypeFromGenes","clearRect","fillRect","generatedImage","getImageData","ssimResult","overloadRatioSsim","ratioMatchingPixel","overloadRatioPixelDiff","diffContext","OffscreenCanvas","getContext","nbPixelsDiff","createImageData","pixelmatch","mutate","mutationRate","vertexMovement","colorModificationRate","force","mutant","probaToMutate","swapBuffer","relativeIndex","isStartingOfAPolygon","isColorInformation","addEventListener","msg","config","configuration","nbColors","enableTransparency","previousPop","previousBest","originalImage","renderingWidth","renderingHeight","ctxOriginal","putImageData","scaledOriginalImage","nextPop","evaluatedPopulation","result","evaluatedInd","evaluatePopulation","popSize","genesSize","generatePopulation","nbVertex","tournamentPool","poolSize","pool","generateTournamentPool","sort","selectCutoff","crossoverParentRatio","sortDescByFitness","elapsedTime","nonImprovingSince","notImprovingSince","response","isRunning","generation","postMessage","console","error"],"mappings":"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","file":"static/js/test.worker.8798f57e.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/react_ag_image/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ssim\"] = factory();\n\telse\n\t\troot[\"ssim\"] = factory();\n})(self, function() {\nreturn ","/**\n * Implements Bezkrovny's ssim-specific logic.\n *\n * Refactor of the TypeScript SSIM implementation by Bezkrovny, modified to match the api of ssim.js\n * and reduce duplication.\n *\n * The original work is available at: https://github.com/igor-bezkrovny/image-quantization which is\n * itself a port of the Java SSIM implementation available at https://github.com/rhys-e/structural-similarity\n * both under MIT license\n *\n * @namespace bezkrovnySsim\n */\nimport { average, variance, covariance } from './math'\nimport { sub } from './matlab'\nimport { Options, Matrix } from './types'\n\n/**\n * Generates a SSIM map based on two input image matrices.\n *\n * Images must be a 2-Dimensional grayscale image\n *\n * This method produces a simliar output to `assets/ssim.m` (~1%) when running on Matlab. It's based\n * of Igor Bezkrovny's TypeScript implementation\n *\n * @method bezkrovnySsim\n * @param {Matrix} pixels1 - The reference matrix\n * @param {Matrix} pixels2 - The second matrix to compare against\n * @param {Options} options - The input options parameter\n * @returns {Matrix} ssim_map - A matrix containing the map of computed SSIMs\n * @public\n * @memberOf bezkrovnySsim\n */\nexport function bezkrovnySsim(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  options: Options\n) {\n  const { windowSize } = options\n  const width = Math.ceil(pixels1.width / windowSize)\n  const height = Math.ceil(pixels1.height / windowSize)\n  const data = new Array(width * height)\n  let counter = 0\n\n  for (let y = 0; y < pixels1.height; y += windowSize) {\n    for (let x = 0; x < pixels1.width; x += windowSize) {\n      const windowWidth = Math.min(windowSize, pixels1.width - x)\n      const windowHeight = Math.min(windowSize, pixels1.height - y)\n\n      const values1 = sub(pixels1, x, windowHeight, y, windowWidth)\n      const values2 = sub(pixels2, x, windowHeight, y, windowWidth)\n\n      data[counter++] = windowSsim(values1, values2, options)\n    }\n  }\n  return { data, width, height }\n}\n\n/**\n * Generates the per-window ssim value\n *\n * @method windowSsim\n * @param {Matrix} values1 - The matrix of the ssim window to compute for image 1\n * @param {Matrix} values2 - The matrix of the ssim window to compute for image 2\n * @param {Options} options - The input options parameter\n * @returns {Number} ssim - The ssim value at the current window\n * @private\n * @memberOf bezkrovnySsim\n */\nfunction windowSsim(\n  { data: values1 }: Matrix,\n  { data: values2 }: Matrix,\n  { bitDepth, k1, k2 }: Options\n): number {\n  const L = 2 ** bitDepth - 1\n  const c1 = (k1 * L) ** 2\n  const c2 = (k2 * L) ** 2\n  const average1 = average(values1)\n  const average2 = average(values2)\n  const σSqx = variance(values1, average1)\n  const σSqy = variance(values2, average2)\n  const σxy = covariance(values1, values2, average1, average2)\n\n  const numerator = (2 * average1 * average2 + c1) * (2 * σxy + c2)\n  const denom1 = average1 ** 2 + average2 ** 2 + c1\n  const denom2 = σSqx + σSqy + c2\n\n  return numerator / (denom1 * denom2)\n}\n","import { Options } from './types'\n\nexport const defaults: Options = {\n  windowSize: 11,\n  k1: 0.01,\n  k2: 0.03,\n  bitDepth: 8,\n  downsample: 'original',\n  ssim: 'weber',\n  maxSize: 256,\n  rgb2grayVersion: 'integer',\n}\n","/**\n * Implements downsampling logic\n *\n * @namespace downsample\n */\nimport { divide2d, sum2d } from './math'\nimport { imfilter, ones, skip2d } from './matlab'\nimport { Matrix, Options } from './types'\n\n/**\n * For a given 2D filter `filter`, downsize image `pixels` by a factor of `f`.\n *\n * @method imageDownsample\n * @param {Matrix} pixels - The matrix to downsample\n * @param {Matrix} filter - The filter to convolve the image with\n * @param {number} f - The downsampling factor (`image size / f`)\n * @returns {Matrix} imdown - The downsampled, filtered image\n * @private\n * @memberOf downsample\n */\nfunction imageDownsample(pixels: Matrix, filter: Matrix, f: number): Matrix {\n  const imdown = imfilter(pixels, filter, 'symmetric', 'same')\n\n  return skip2d(imdown, [0, f, imdown.height], [0, f, imdown.width])\n}\n\n/**\n * Downsamples images greater than `maxSize` pixels on the smallest direction. If neither image\n * exceeds these dimensions they are returned as they are.\n *\n * It replicates the same logic than the original matlab scripts\n *\n * @method originalDownsample\n * @param {Matrix} pixels1 - The first matrix to downsample\n * @param {Matrix} pixels2 - The second matrix to downsample\n * @param {number} [maxSize=256] - The maximum size on the smallest dimension\n * @returns {[Matrix, Matrix]} ssim_map - A matrix containing the map of computed SSIMs\n * @private\n * @memberOf downsample\n */\nfunction originalDownsample(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  maxSize = 256\n): [Matrix, Matrix] {\n  const factor = Math.min(pixels1.width, pixels2.height) / maxSize\n  const f = Math.round(factor)\n\n  if (f > 1) {\n    let lpf = ones(f)\n\n    lpf = divide2d(lpf, sum2d(lpf))\n\n    pixels1 = imageDownsample(pixels1, lpf, f)\n    pixels2 = imageDownsample(pixels2, lpf, f)\n  }\n\n  return [pixels1, pixels2]\n}\n\n/**\n * Determines the downsizing algorithm to implement (if any) to the reference and target images\n *\n * @method downsample\n * @param {[Matrix, Matrix]} pixels - The first and second matrices to downsample\n * @param {Object} options - The inputs options object\n * @returns {[Matrix, Matrix]} pixels - An array containing the 2 downsized images\n * @public\n * @memberOf downsample\n */\nexport function downsample(\n  pixels: [Matrix, Matrix],\n  options: Options\n): [Matrix, Matrix] {\n  if (options.downsample === 'original') {\n    return originalDownsample(pixels[0], pixels[1], options.maxSize)\n  }\n  // else if options.downsample === 'fast' -> the image is downsampled when read (readpixels.js)\n  // else do not downsample\n  return pixels\n}\n","/**\n * SSIM External API\n *\n * @module main\n */\nimport { rgb2gray, rgb2grayInteger } from './matlab'\nimport { mean2d } from './math'\nimport { ssim as fastSsim } from './ssim'\nimport { originalSsim } from './originalSsim'\nimport { bezkrovnySsim } from './bezkrovnySsim'\nimport { downsample } from './downsample'\nimport { defaults } from './defaults'\nimport {\n  Options,\n  Images,\n  Matrices,\n  Matrix,\n  MSSIMMatrix,\n  ImageData,\n} from './types'\nimport { weberSsim } from './weberSsim'\n\nexport { Options, Matrix }\n\nconst ssimTargets = {\n  fast: fastSsim,\n  original: originalSsim,\n  bezkrovny: bezkrovnySsim,\n  weber: weberSsim,\n}\n\nfunction validateOptions(options: Options) {\n  Object.keys(options).forEach((option) => {\n    if (!(option in defaults)) {\n      throw new Error(`\"${option}\" is not a valid option`)\n    }\n  })\n  if ('k1' in options && (typeof options.k1 !== 'number' || options.k1 < 0)) {\n    throw new Error(`Invalid k1 value. Default is ${defaults.k1}`)\n  }\n  if ('k2' in options && (typeof options.k2 !== 'number' || options.k2 < 0)) {\n    throw new Error(`Invalid k2 value. Default is ${defaults.k2}`)\n  }\n  if (!(options.ssim in ssimTargets)) {\n    throw new Error(\n      `Invalid ssim option (use: ${Object.keys(ssimTargets).join(', ')})`\n    )\n  }\n}\n\nexport function getOptions(userOptions?: Partial<Options>): Options {\n  const options = { ...defaults, ...userOptions }\n\n  validateOptions(options)\n\n  return options\n}\n\nfunction validateDimensions([pixels1, pixels2, options]: Images): Images {\n  if (pixels1.width !== pixels2.width || pixels1.height !== pixels2.height) {\n    throw new Error('Image dimensions do not match')\n  }\n\n  return [pixels1, pixels2, options]\n}\n\nfunction toGrayScale([pixels1, pixels2, options]: Images): Matrices {\n  if (options.rgb2grayVersion === 'original') {\n    return [rgb2gray(pixels1), rgb2gray(pixels2), options]\n  } else {\n    return [rgb2grayInteger(pixels1), rgb2grayInteger(pixels2), options]\n  }\n}\n\nfunction toResize([pixels1, pixels2, options]: Matrices): Matrices {\n  const pixels = downsample([pixels1, pixels2], options)\n\n  return [pixels[0], pixels[1], options]\n}\n\nfunction comparison([pixels1, pixels2, options]: Matrices): Matrix {\n  return ssimTargets[options.ssim](pixels1, pixels2, options)\n}\n\n/**\n * @method ssim - The ssim method. You can call the package directly or through the `ssim` property.\n * @public\n * @example import mod = from 'ssim.js';\n * mod(imgBuffer1, imgBuffer2);\n * mod.ssim(imgBuffer1, imgBuffer2);\n */\nexport function ssim(\n  image1: ImageData,\n  image2: ImageData,\n  userOptions?: Partial<Options>\n): {\n  ssim_map: Matrix\n  mssim: number\n  performance: number\n} {\n  const start = new Date().getTime()\n  const options = getOptions(userOptions)\n  const ssimMap = comparison(\n    toResize(toGrayScale(validateDimensions([image1, image2, options])))\n  )\n  const mssim =\n    (ssimMap as MSSIMMatrix).mssim !== undefined\n      ? (ssimMap as MSSIMMatrix).mssim\n      : mean2d(ssimMap)\n  return {\n    mssim,\n    ssim_map: ssimMap,\n    performance: new Date().getTime() - start,\n  }\n}\n\nexport default ssim\n","/**\n * Generates all basic arithmetic and matrix computations required\n *\n * Most of these methods use plain for loops and reduce nested calls. This results in about ~100x\n * improvement on SSIM computation for 512x512 images on recent versions of node (~v6.7) over\n * implementations using map or reduce.\n *\n * @namespace math\n */\nimport { Matrix } from './types'\n\n/**\n * Computes the mean value of a given array. It is the sum of a list of numbers divided by the\n * number of numbers in the list.\n *\n * @method average\n * @param {Number[]} xn - The target array\n * @returns {Number} average - The mean value of all elements within the array\n * @public\n * @memberOf math\n * @since 0.0.1\n */\nexport function average(xn: number[]): number {\n  return sum(xn) / xn.length\n}\n\n/**\n * Computes the sum of a given array. It adds all values within the array and returns the total\n *\n * @method sum\n * @param {Number[]} xn - The target array\n * @returns {Number} sum - The total value\n * @private\n * @memberOf math\n * @since 0.0.1\n */\nexport function sum(xn: number[]): number {\n  let out = 0\n\n  for (let x = 0; x < xn.length; x++) {\n    out += xn[x]\n  }\n  return out\n}\n\n/**\n * Computes the largest integer less than or equal to a given number for each member of a given\n * array.\n *\n * @method floor\n * @param {Number[]} xn - The target array\n * @returns {Number[]} floorArr - An array with the Math.floor value for each element of the target\n * array\n * @private\n * @memberOf math\n * @since 0.0.1\n */\nexport function floor(xn: number[]): number[] {\n  const out = new Array(xn.length)\n\n  for (let x = 0; x < xn.length; x++) {\n    out[x] = Math.floor(xn[x])\n  }\n\n  return out\n}\n\n/**\n * Computes the sum of all elements within a matrix\n *\n * @method sum2d\n * @param {Matrix} A - The input matrix\n * @returns {Number} sum - The total value of adding each cell\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function sum2d({ data }: Matrix): number {\n  let out = 0\n\n  for (let x = 0; x < data.length; x++) {\n    out += data[x]\n  }\n\n  return out\n}\n\n/**\n * Adds values of two matrices of the same size\n *\n * @method add2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell sum of `A` and `B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction add2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < height; x++) {\n    const offset = x * width\n\n    for (let y = 0; y < width; y++) {\n      data[offset + y] = ref1[offset + y] + ref2[offset + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Subtracts values of second matrix from the first one. It assumes both matrices are of the same\n * size\n *\n * @method subtract2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell subtraction of `A` minus `B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction subtract2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < height; x++) {\n    const offset = x * width\n\n    for (let y = 0; y < width; y++) {\n      data[offset + y] = ref1[offset + y] - ref2[offset + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Adds a constant value two each matrix cell\n *\n * @method add2dScalar\n * @param {Matrix} A - The first input matrix\n * @param {Number} increase - The value to add\n * @returns {Matrix} B - The cell-by-cell matrix sum of `A` and `increase`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction add2dScalar(\n  { data: ref, width, height }: Matrix,\n  increase: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = ref[x] + increase\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Adds values of two matrices of the same size or a matrix and a constant\n *\n * @method add2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} increase - The second input matrix or the constant value\n * @returns {Matrix} B - A matrix with a cell-by-cell sum of the first and second parameters\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function add2d(A: Matrix, increase: Matrix | number): Matrix {\n  if (typeof increase === 'number') {\n    return add2dScalar(A, increase)\n  }\n  return add2dMx(A, increase)\n}\n\n/**\n * Subtracts values of two matrices of the same size or a matrix and a constant\n *\n * @method subtract2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} decrease - The second input matrix or the constant value\n * @returns {Matrix} B - A matrix with a cell-by-cell subtraction of the first parameter minus the\n * second one\n * @public\n * @memberOf math\n */\nexport function subtract2d(A: Matrix, decrease: Matrix | number): Matrix {\n  if (typeof decrease === 'number') {\n    return add2dScalar(A, -decrease)\n  }\n  return subtract2dMx(A, decrease)\n}\n\n/**\n * Divides each matrix cell by a constant value\n *\n * @method divide2dScalar\n * @param {Matrix} A - The first input matrix\n * @param {Number} divisor - The value to divide by\n * @returns {Matrix} B - The cell-by-cell matrix divison of `A` and `divisor`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction divide2dScalar(\n  { data: ref, width, height }: Matrix,\n  divisor: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = ref[x] / divisor\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Divides, cell-by-cell, values of two matrices of the same size\n *\n * @method divide2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell division of `A`/`B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction divide2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < ref1.length; x++) {\n    data[x] = ref1[x] / ref2[x]\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Divides values of two matrices of the same size or between a matrix and a constant\n *\n * @method divide2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} divisor - The second input matrix or the constant value\n * @returns {Matrix} B - A matrix with the cell-by-cell division of the first and second parameters\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function divide2d(A: Matrix, divisor: Matrix | number): Matrix {\n  if (typeof divisor === 'number') {\n    return divide2dScalar(A, divisor)\n  }\n  return divide2dMx(A, divisor)\n}\n\n/**\n * Multiplies each matrix cell by a constant value\n *\n * @method multiply2dScalar\n * @param {Matrix} A - The first input matrix\n * @param {Number} multiplier - The value to multiply each cell with\n * @returns {Matrix} B - The cell-by-cell matrix multiplication of `A` and `multiplier`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction multiply2dScalar(\n  { data: ref, width, height }: Matrix,\n  multiplier: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = ref[x] * multiplier\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Multiplies, cell-by-cell, values of two matrices of the same size\n *\n * @method multiply2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell multiplication of `A` * `B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction multiply2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < ref1.length; x++) {\n    data[x] = ref1[x] * ref2[x]\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Multiplies values of two matrices of the same size or between a matrix and a constant\n *\n * @method multiply2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} multiplier - The second input matrix or the constant value\n * @returns {Matrix} out - A matrix with the cell-by-cell multiplication of the first and second\n * parameters\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function multiply2d(A: Matrix, multiplier: Matrix | number): Matrix {\n  if (typeof multiplier === 'number') {\n    return multiply2dScalar(A, multiplier)\n  }\n  return multiply2dMx(A, multiplier)\n}\n\n/**\n * Generates the cell-by-cell square value of a target matrix\n *\n * @method square2d\n * @param {Matrix} A - The target matrix\n * @returns {Matrix} B - A matrix with squared value of each cell\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function square2d(A: Matrix): Matrix {\n  return multiply2d(A, A)\n}\n\n/**\n * Calculates the total mean value for a given matrix\n *\n * @method mean2d\n * @param {Matrix} A - The target matrix\n * @returns {Number} mean - The total mean of each cell\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function mean2d(A: Matrix): number {\n  return sum2d(A) / A.data.length\n}\n\n/**\n * Computes the variance for a given array\n *\n * @method variance\n * @param {Array<Number>} values - The target array\n * @param {Number} [avg=average(values)] - If specified, it will use this values as the average of\n * the array values. If not, it will compute the actual average\n * @returns {Number} varx - The resulting variance value\n * @public\n * @memberOf math\n */\nexport function variance(\n  values: number[],\n  avg: number = average(values)\n): number {\n  let varx = 0\n  let i = values.length\n\n  while (i--) {\n    varx += (values[i] - avg) ** 2\n  }\n\n  return varx / values.length\n}\n\n/**\n * Computes the covariance between 2 arrays\n *\n * @method covariance\n * @param {Array<Number>} values1 - The first target array\n * @param {Array<Number>} values2 - The second target array\n * @param {Number} [average1=average(values)] - If specified, it will use this values as the average\n * of the first array. If not, it will compute the actual average\n * @param {Number} [average2=average(values)] - If specified, it will use this values as the average\n * of the second array. If not, it will compute the actual average\n * @returns {Number} cov - The resulting covariance\n * @public\n * @memberOf math\n */\nexport function covariance(\n  values1: number[],\n  values2: number[],\n  average1: number = average(values1),\n  average2: number = average(values2)\n): number {\n  let cov = 0\n  let i = values1.length\n\n  while (i--) {\n    cov += (values1[i] - average1) * (values2[i] - average2)\n  }\n\n  return cov / values1.length\n}\n","import { multiply2d } from '../math'\nimport { ones } from './ones'\nimport { sub } from './sub'\nimport { zeros } from './zeros'\nimport { Matrix, Shape } from '../types'\n\n/**\n * `C = conv2(a,b)` computes the two-dimensional convolution of matrices `a` and `b`. If one of\n * these matrices describes a two-dimensional finite impulse response (FIR) filter, the other matrix\n * is filtered in two dimensions. The size of `c` is determined as follows:\n *\n * ```\n * if [ma,na] = size(a), [mb,nb] = size(b), and [mc,nc] = size(c), then\n * mc = max([ma+mb-1,ma,mb]) and nc = max([na+nb-1,na,nb]).\n * ```\n *\n * `shape` returns a subsection of the two-dimensional convolution, based on one of these values for\n * the parameter:\n *\n * - **full**: Returns the full two-dimensional convolution (default).\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges. Using this option, `size(c) === max([ma-max(0,mb-1),na-max(0,nb-1)],0)`\n *\n * @method mxConv2\n * @param {Matrix} a - The first matrix\n * @param {Matrix} b - The second matrix\n * @param {String} [shape='full'] - One of 'full' / 'same' / 'valid'\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction mxConv2(\n  { data: ref, width: refWidth, height: refHeight }: Matrix,\n  b: Matrix,\n  shape: Shape = 'full'\n): Matrix {\n  const cWidth = refWidth + b.width - 1\n  const cHeight = refHeight + b.height - 1\n  const { data } = zeros(cHeight, cWidth)\n\n  /**\n   * Computing the convolution is the most computentionally intensive task for SSIM and we do it\n   * several times.\n   *\n   * This section has been optimized for performance and readability suffers.\n   */\n  for (let r1 = 0; r1 < b.height; r1++) {\n    for (let c1 = 0; c1 < b.width; c1++) {\n      const br1c1 = b.data[r1 * b.width + c1]\n\n      if (br1c1) {\n        for (let i = 0; i < refHeight; i++) {\n          for (let j = 0; j < refWidth; j++) {\n            data[(i + r1) * cWidth + j + c1] += ref[i * refWidth + j] * br1c1\n          }\n        }\n      }\n    }\n  }\n\n  const c = {\n    data,\n    width: cWidth,\n    height: cHeight,\n  }\n\n  return reshape(c, shape, refHeight, b.height, refWidth, b.width)\n}\n\n/**\n * `C = boxConv(a,b)` computes the two-dimensional convolution of a matrix `a` and box kernel `b`.\n *\n * The `shape` parameter returns a subsection of the two-dimensional convolution as defined by\n * mxConv2.\n *\n * @method boxConv\n * @param {Matrix} a - The first matrix\n * @param {Matrix} b - The box kernel\n * @param {String} [shape='full'] - One of 'full' / 'same' / 'valid'\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction boxConv(\n  a: Matrix,\n  { data, width, height }: Matrix,\n  shape: Shape = 'full'\n): Matrix {\n  const b1 = ones(height, 1)\n  const b2 = ones(1, width)\n  const out = convn(a, b1, b2, shape)\n\n  return multiply2d(out, data[0])\n}\n\n/**\n * Determines whether all values in an array are the same so that the kernel can be treated as a box\n * kernel\n *\n * @method isBoxKernel\n * @param {Matrix} a - The input matrix\n * @returns {Boolean} boxKernel - Returns true if all values in the matrix are the same, false\n * otherwise\n * @private\n * @memberOf matlab\n */\nfunction isBoxKernel({ data }: Matrix): boolean {\n  const expected = data[0]\n\n  for (let i = 1; i < data.length; i++) {\n    if (data[i] !== expected) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * `C = convn(a,b1, b2)` computes the two-dimensional convolution of matrices `a.*b1.*b2`.\n *\n * The size of `c` is determined as follows:\n *\n * ```\n * if [ma,na] = size(a), [mb] = size(b1), [nb] = size(b2) and [mc,nc] = size(c), then\n * mc = max([ma+mb-1,ma,mb]) and nc = max([na+nb-1,na,nb]).\n * ```\n *\n * `shape` returns a section of the two-dimensional convolution, based on one of these values for\n * the parameter:\n *\n * - **full**: Returns the full two-dimensional convolution (default).\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges. Using this option, `size(c) === max([ma-max(0,mb-1),na-max(0,nb-1)],0)`\n *\n * This method mimics Matlab's `convn` method but limited to 2 1 dimensional kernels.\n *\n * @method convn\n * @param {Matrix} a - The first matrix\n * @param {Matrix} b1 - The first 1-D kernel\n * @param {Matrix} b2 - The second 1-D kernel\n * @param {String} [shape='full'] - One of 'full' / 'same' / 'valid'\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction convn(\n  a: Matrix,\n  b1: Matrix,\n  b2: Matrix,\n  shape: Shape = 'full'\n): Matrix {\n  const mb = Math.max(b1.height, b1.width)\n  const nb = Math.max(b2.height, b2.width)\n  const temp = mxConv2(a, b1, 'full')\n  const c = mxConv2(temp, b2, 'full')\n\n  return reshape(c, shape, a.height, mb, a.width, nb)\n}\n\n/**\n * `reshape` crops the resulting convolution matrix to match the values specified in `shape`.\n *\n * - **full**: Returns the input\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges\n *\n * @method reshape\n * @param {Matrix} c - The output matrix\n * @param {String} shape - One of 'full' / 'same' / 'valid'\n * @param {Number} ma - The number of rows of the input matrix\n * @param {Number} mb - The number of rows of the input filter\n * @param {Number} na - The number of columns of the input matrix\n * @param {Number} nb - The number of columns of the input filter\n * @returns {Matrix} c - Returns the input convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction reshape(\n  c: Matrix,\n  shape: Shape,\n  ma: number,\n  mb: number,\n  na: number,\n  nb: number\n): Matrix {\n  if (shape === 'full') {\n    return c\n  } else if (shape === 'same') {\n    const rowStart = Math.ceil((c.height - ma) / 2)\n    const colStart = Math.ceil((c.width - na) / 2)\n\n    return sub(c, rowStart, ma, colStart, na)\n  }\n\n  return sub(c, mb - 1, ma - mb + 1, nb - 1, na - nb + 1)\n}\n\n/**\n * `C = conv2(a,b)` computes the two-dimensional convolution of matrices `a` and `b`. If one of\n * these matrices describes a two-dimensional finite impulse response (FIR) filter, the other matrix\n * is filtered in two dimensions.\n *\n * The size of `c` is determined as follows:\n *\n * ```\n * if [ma,na] = size(a), [mb,nb] = size(b), and [mc,nc] = size(c), then\n * mc = max([ma+mb-1,ma,mb]) and nc = max([na+nb-1,na,nb]).\n * ```\n *\n * `shape` returns a subsection of the two-dimensional convolution, based on one of these values for\n * the parameter:\n *\n * - **full**: Returns the full two-dimensional convolution (default).\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges. Using this option, `size(c) === max([ma-max(0,mb-1),na-max(0,nb-1)],0)`\n *\n * Alternatively, 2 1-D filters may be provided as parameters, following the format:\n * `conv2(a, b1, b2, shape)`. This is similar to Matlab's implementation allowing any number of 1-D\n * filters to be applied but limited to 2\n *\n * This method mimics Matlab's `conv2` method.\n *\n * Given:\n * const A = rand(3);\n * const B = rand(4);\n *\n * @example conv2(A,B); // output is 6-by-6\n * {\n *   data: [\n *     0.1838, 0.2374, 0.9727, 1.2644, 0.7890, 0.3750,\n *     0.6929, 1.2019, 1.5499, 2.1733, 1.3325, 0.3096,\n *     0.5627, 1.5150, 2.3576, 3.1553, 2.5373, 1.0602,\n *     0.9986, 2.3811, 3.4302, 3.5128, 2.4489, 0.8462,\n *     0.3089, 1.1419, 1.8229, 2.1561, 1.6364, 0.6841,\n *     0.3287, 0.9347, 1.6464, 1.7928, 1.2422, 0.5423\n *   ],\n *   width: 6,\n *   height: 6\n * }\n *\n * @example conv2(A,B,'same') => // output is the same size as A: 3-by-3\n * {\n *   data: [\n *     2.3576, 3.1553, 2.5373,\n *     3.4302, 3.5128, 2.4489,\n *     1.8229, 2.1561, 1.6364\n *   ],\n *   width: 3,\n *   height: 3\n * }\n *\n * @method conv2\n * @param {Array} args - The list of arguments, see `mxConv2` and `convn` for the exact parameters\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function conv2(\n  ...args: Parameters<typeof boxConv | typeof convn | typeof mxConv2>\n) {\n  if (args[2] && (args[2] as Matrix).data) {\n    return convn(...(args as Parameters<typeof convn>))\n  } else if (isBoxKernel(args[1])) {\n    return boxConv(...(args as Parameters<typeof boxConv>))\n  }\n  return mxConv2(...(args as Parameters<typeof mxConv2>))\n}\n","import { conv2 } from './conv2'\nimport { Matrix, Shape } from '../types'\n\n/**\n * Rotates a matrix 180deg.\n *\n * @example\n * 1 2 3 4  becomes:  8 7 6 5\n * 5 6 7 8            4 3 2 1\n *\n * @method rotate1802d\n * @param {Matrix} mx - The input matrix\n * @returns {Matrix} out - The rotated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction rotate1802d({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(ref.length)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      data[i * width + j] = ref[(height - 1 - i) * width + width - 1 - j]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Given a matrix X and a two-dimensional FIR filter h, filter2 rotates your filter matrix 180\n * degrees to create a convolution kernel. It then calls conv2, the two-dimensional convolution\n * function, to implement the filtering operation.\n *\n * This method mimics Matlab's `filter2` method\n *\n * @method filter2\n * @param {Matrix} h - The FIR filter\n * @param {Matrix} X - The input matrix\n * @param string [shape='same'] - The convolution shape\n * @returns {Matrix} conv - The 2D convolution of X with h\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function filter2(h: Matrix, X: Matrix, shape: Shape = 'same'): Matrix {\n  return conv2(X, rotate1802d(h), shape)\n}\n","import { Matrix } from '../types'\nimport { sum2d, divide2d } from '../math'\n\n/**\n * Creates a matrix of lenght `2 * length + 1` with values being the sum of the square of the\n * distance for each component from the center. E.g:\n *\n * For a length of 5 it results in a matrix size of 11. Looking at [0, 0] (distance: [-5, -5] from\n * the center), the value at that position becomes `-5^2 + -5^2 = 50`\n *\n * @method rangeSquare2d\n * @param {Number} length - The maxium distance from the matrix center\n * @returns {Matrix} mx - The generated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction rangeSquare2d(length: number): Matrix {\n  const size = length * 2 + 1\n  const data = new Array(size ** 2)\n\n  for (let x = 0; x < size; x++) {\n    for (let y = 0; y < size; y++) {\n      data[x * size + y] = (x - length) ** 2 + (y - length) ** 2\n    }\n  }\n\n  return {\n    data,\n    width: size,\n    height: size,\n  }\n}\n\n/**\n * Applies a gaussian filter of sigma to a given matrix\n *\n * @method gaussianFilter2d\n * @param {Matrix} A - The input matrix\n * @param {Number} σ - The sigma value\n * @returns {Matrix} B - The matrix with the gaussian filter applied\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction gaussianFilter2d(\n  { data: ref, width, height }: Matrix,\n  σ: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = Math.exp(-ref[x] / (2 * σ ** 2))\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n/**\n * Create predefined 2-D filter\n *\n * `h = fspecial(type, parameters)` accepts the filter specified by type plus additional modifying\n * parameters particular to the type of filter chosen. If you omit these arguments, fspecial uses\n * default values for the parameters.\n *\n * This method mimics Matlab's `fspecial2` method with `type = 'gaussian'`. `hsize` cannot be a\n * vector (unlike Matlab's implementation), only a Number is accepted.\n *\n * `h = fspecial('gaussian', hsize, sigma)` returns a rotationally symmetric Gaussian lowpass filter\n * of size `hsize` with standard deviation sigma (positive). In this implementation `hsize` will\n * always be a scalar, which will result in `h` being a square matrix.\n *\n * The gaussian logic follows: hg(hsize) = e^(-2*hsize^2 / 2σ^2)\n *\n * @example\n *   fspecial('gaussian', 3, 1.5) === {\n *     data: [\n *       0.094742, 0.118318, 0.094742,\n *       0.118318, 0.147761, 0.118318,\n *       0.094742, 0.118318, 0.094742\n *     ],\n *     width: 3,\n *     height: 3\n *   };\n *\n * @method fspecial\n * @param {String} [type='gaussian'] - The type of 2D filter to create (coerced to 'gaussian')\n * @param {Number} [hsize=3] - The length of the filter\n * @param {Number} [σ=1.5] - The filter sigma value\n * @returns {Matrix} c - Returns the central part of the convolution of the same\n * size as `a`.\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function fspecial(_type?: 'gaussian', hsize = 3, σ = 1.5): Matrix {\n  hsize = (hsize - 1) / 2\n\n  const pos = rangeSquare2d(hsize)\n  const gauss = gaussianFilter2d(pos, σ)\n  const total = sum2d(gauss)\n\n  return divide2d(gauss, total)\n}\n","import { mod } from './mod'\nimport { padarray, PaddingValue } from './padarray'\nimport { floor } from '../math'\nimport { filter2 } from './filter2'\nimport { Matrix, Shape } from '../types'\n\n/**\n * Adds padding to input matrix A\n *\n * @method padMatrix\n * @param {Matrix} A - The target matrix\n * @param {Number} frows - The number of rows in the filter\n * @param {Number} fcols - The number of columns in the filter\n * @param {String} pad - The type of padding to apply\n * @param {Matrix} B - The padded input matrix\n * @private\n * @memberOf matlab\n */\nfunction padMatrix(\n  A: Matrix,\n  frows: number,\n  fcols: number,\n  pad: PaddingValue\n): Matrix {\n  A = padarray(A, floor([frows / 2, fcols / 2]) as [number, number], pad)\n  if (mod(frows, 2) === 0) {\n    // remove the last row\n    A.data = A.data.slice(0, -A.width)\n    A.height--\n  }\n  if (mod(fcols, 2) === 0) {\n    // remove the last column\n    const data = []\n\n    for (let x = 0; x < A.data.length; x++) {\n      if ((x + 1) % A.width !== 0) {\n        data.push(A.data[x])\n      }\n    }\n    A.data = data\n    A.width--\n  }\n  return A\n}\n\n/**\n * Gets the `shape` parameter for `conv2` based on the `resSize` parameter for `imfilter`. In most\n * cases they are equivalent except for when `resSize` equals \"same\" which is converted to \"valid\".\n *\n * @method getConv2Size\n * @param {String} resSize - The format to use for the `imfilter` call\n * @returns {String} shape - The shape value to use for `conv2`\n * @private\n * @memberOf matlab\n */\nfunction getConv2Size(resSize: Shape): Shape {\n  if (resSize === 'same') {\n    resSize = 'valid'\n  }\n  return resSize\n}\n\n/**\n * `B = imfilter(A,f)` filters a 2-dimensional array `A` with the 2-dimensional filter `f`. The\n * result `B` has the same size as `A`.\n *\n * `imfilter` computes each element of the output, `B`. If `A` is an integer, `imfilter` will not\n * truncate the output elements that exceed the range, and it will not round fractional values.\n *\n * This method mimics Matlab's `imfilter` method with `padval = 'symmetric'` without integer\n * rounding. No other options have been implemented and, if set, they will be ignored.\n *\n * @method imfilter\n * @param {Matrix} A - The target matrix\n * @param {Matrix} f - The filter to apply\n * @param {String} [pad=\"symmetric\"] - The type of padding. Only \"symmetric\" is implemented\n * @param {String} [resSize=\"same\"] - The format to use for the filter size. Valid values are:\n * \"same\", \"valid\" and \"full\"\n * @returns {Matrix} B - The filtered array\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function imfilter(\n  A: Matrix,\n  f: Matrix,\n  pad: PaddingValue = 'symmetric',\n  resSize: Shape = 'same'\n) {\n  A = padMatrix(A, f.width, f.height, pad)\n  resSize = getConv2Size(resSize)\n  return filter2(f, A, resSize)\n}\n","/**\n * Implements Matlab functions or functionality.\n *\n * The goal here is not a perfect reproduction of matlab logic but just a minimal implementation\n * needed to correctly reproduce the SSIM matlab script.\n *\n * That means that functionality used will be implemented but additional / unused parameters will\n * not.\n *\n * @namespace matlab\n */\nexport * from './conv2'\nexport * from './filter2'\nexport * from './fspecial'\nexport * from './imfilter'\nexport * from './normpdf'\nexport * from './ones'\nexport * from './padarray'\nexport * from './rgb2gray'\nexport * from './skip2d'\nexport * from './sub'\nexport * from './transpose'\nexport * from './zeros'\n","import { Matrix } from '../../types'\n\n/**\n * Create a matrix with each cell with the value of `num`\n *\n * @method numbers\n * @param {Number} height - The number of rows\n * @param {Number} width - The number of columns\n * @param {Number} num - The value to set on each cell\n * @returns {Matrix} B - An n-by-m matrix of `num`\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function numbers(height: number, width: number, num: number): Matrix {\n  const size = width * height\n  const data = new Array(size)\n\n  for (let x = 0; x < size; x++) {\n    data[x] = num\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","/**\n * `M = mod(X,Y)` returns the remainder `X - Y.*floor(X./Y)` for nonzero `Y`, and returns `X`\n * otherwise. `mod(X,Y)` always differs from `X` by a multiple of `Y`.\n *\n * So long as operands `X` and `Y` are of the same sign, the function `mod(X,Y)` returns the same\n * result as does `rem(X,Y)`. However, for positive `X` and `Y`, `mod(-x,y) = rem(-x,y)+y`.\n *\n * The mod function is useful for congruence relationships: x and y are congruent (mod m) if and\n * only if mod(x,m) == mod(y,m).\n *\n * This method mimics Matlab's `mod` method\n *\n * @method mod\n * @param {Number} x - The dividend\n * @param {Numvwe} y - The divisor\n * @returns {Number} M - Returns the signed remainder after division.\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function mod(x: number, y: number): number {\n  return x - y * Math.floor(x / y)\n}\n","import { Matrix } from '../types'\n\n/**\n * `Y = normpdf(X,μ,σ)` computes the pdf at each of the values in `X` using the normal\n * distribution with mean `μ` and standard deviation `σ`. `X`, `μ`, and `σ` can be vectors,\n * matrices, or multidimensional arrays that all have the same size. A scalar input is expanded to a\n * constant array with the same dimensions as the other inputs. The parameters in `σ` must be\n * positive.\n *\n * The normal pdf is: `y = f(x|μ,σ) = (1 / (σ√(2π))) * e^(-(x-μ)^2/2σ^2)`\n *\n * The likelihood function is the pdf viewed as a function of the parameters. Maximum likelihood\n * estimators (MLEs) are the values of the parameters that maximize the likelihood function for a\n * fixed value of `x`.\n *\n * The standard normal distribution has `µ = 0` and `σ = 1`.\n * If x is standard normal, then `xσ + µ` is also normal with mean `µ` and standard deviation `σ`.\n * Conversely, if `y` is normal with mean `µ` and standard deviation `σ`, then `x = (y – µ) / σ` is\n * standard normal.\n *\n * `Y = normpdf(X)` uses the standard normal distribution (`µ = 0`, `σ = 1`).\n * `Y = normpdf(X,µ)` uses the normal distribution with unit standard deviation (`σ = 1`).\n *\n * @example normpdf({ data: [2, 1, 0, 1, 2], width: 5, height: 1 }, 0, 1.5) =>\n *   { data: [ 0.10934, 0.21297, 0.26596, 0.21297, 0.10934], width: 5, height: 1 }\n *\n * @method normpdf\n * @param {Matrix} X - The input matrix\n * @param {Number} [µ=0] - The length of the filter\n * @param {Number} [σ=1] - The filter sigma value\n * @returns {Matrix} Y - Returns the central part of the convolution of the same\n * size as `a`.\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function normpdf(\n  { data: ref, width, height }: Matrix,\n  µ = 0,\n  σ = 1\n): Matrix {\n  // data = ((2 * pi)^(-1 / 2)) * exp(-((x - µ) / σ)^2 / 2) / σ;\n  const SQ2PI = 2.506628274631000502415765284811\n  const data = new Array(ref.length)\n\n  for (let i = 0; i < ref.length; i++) {\n    const z = (ref[i] - µ) / σ\n\n    data[i] = Math.exp(-(z ** 2) / 2) / (σ * SQ2PI)\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\nimport { numbers } from './internal/numbers'\n\n/**\n * Create a matrix of all ones\n *\n * This method mimics Matlab's `ones` method\n *\n * @method ones\n * @param {Number} height - The height of the matrix (rows)\n * @param {Number} [width=height] - The width of the matrix (columns)\n * @returns {Matrix} B - An n-by-m matrix of ones\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function ones(height: number, width: number = height): Matrix {\n  return numbers(height, width, 1)\n}\n","import { Matrix } from '../types'\nimport { mod } from './mod'\n\n/**\n * Mirrors a matrix horizontally.\n *\n * @example\n * 1 2 3 4  becomes:  4 3 2 1\n * 5 6 7 8            8 7 6 5\n *\n * @method mirrorHorizonal\n * @param {Matrix} A - The input matrix\n * @returns {Matrix} B - The rotated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction mirrorHorizonal({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < height; x++) {\n    for (let y = 0; y < width; y++) {\n      data[x * width + y] = ref[x * width + width - 1 - y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Mirrors a matrix vertically.\n *\n * @example\n * 1 2 3 4  becomes:  9 0 F E\n * 5 6 7 8            5 6 7 8\n * 9 0 F E            1 2 3 4\n *\n * @method mirrorVertical\n * @param {Matrix} A - The input matrix\n * @returns {Matrix} B - The rotated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction mirrorVertical({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < height; x++) {\n    for (let y = 0; y < width; y++) {\n      data[x * width + y] = ref[(height - 1 - x) * width + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Concatenates 2 matrices of the same height horizontally.\n *\n * @example\n * 1 2   3 4  becomes:  1 2 3 4\n * 5 6   7 8            5 6 7 8\n *\n * @method concatHorizontal\n * @param {Matrix} A - The first matrix\n * @param {Matrix} B - The second matrix\n * @returns {Matrix} out - The combined matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction concatHorizontal(A: Matrix, B: Matrix): Matrix {\n  const width = A.width + B.width\n  const data = new Array(A.height * width)\n\n  for (let x = 0; x < A.height; x++) {\n    for (let y = 0; y < A.width; y++) {\n      data[x * width + y] = A.data[x * A.width + y]\n    }\n    for (let y = 0; y < B.width; y++) {\n      data[x * width + y + A.width] = B.data[x * B.width + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height: A.height,\n  }\n}\n\n/**\n * Concatenates 2 matrices of the same height vertically.\n *\n * @example\n * 1 2   3 4  becomes:  1 2\n * 5 6   7 8            5 6\n *                      3 4\n *                      7 8\n *\n * @method concatVertical\n * @param {Matrix} A - The first matrix\n * @param {Matrix} B - The second matrix\n * @returns {Matrix} out - The combined matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction concatVertical(A: Matrix, B: Matrix): Matrix {\n  return {\n    data: A.data.concat(B.data),\n    height: A.height + B.height,\n    width: A.width,\n  }\n}\n\n/**\n * Adds 2 * `pad` cells to a matrix horizontally. The values used are mirrored from the input\n * matrix.\n *\n * @example\n * with padding 1:\n * 1 2 3 4   becomes:  1 1 2 3 4 4\n * 5 6 7 8             5 5 6 7 8 8\n *\n * With padding 2:\n * 1 2 3 4   becomes:  2 1 1 2 3 4 4 3\n * 5 6 7 8             6 5 5 6 7 8 8 7\n *\n * @method padHorizontal\n * @param {Matrix} A - The input matrix\n * @param {Number} pad - The nummber of cells to add to each side (left / right)\n * @returns {Matrix} B - The padded matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction padHorizontal(A: Matrix, pad: number): Matrix {\n  const width = A.width + 2 * pad\n  const data = new Array(width * A.height)\n  const mirrored = concatHorizontal(A, mirrorHorizonal(A))\n\n  for (let x = 0; x < A.height; x++) {\n    for (let y = -pad; y < A.width + pad; y++) {\n      data[x * width + y + pad] =\n        mirrored.data[x * mirrored.width + mod(y, mirrored.width)]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height: A.height,\n  }\n}\n\n/**\n * Adds 2 * `pad` cells to a matrix vertically. The values used are mirrored from the input\n * matrix.\n *\n * @example\n * with padding 1:\n * 1 2 3 4   becomes:  1 2 3 4\n * 5 6 7 8             1 2 3 4\n *                     5 6 7 8\n *                     5 6 7 8\n * With padding 2:\n * 1 2 3 4   becomes:  5 6 7 8\n * 5 6 7 8             1 2 3 4\n *                     1 2 3 4\n *                     5 6 7 8\n *                     5 6 7 8\n *                     1 2 3 4\n *\n * @method padVertical\n * @param {Matrix} A - The input matrix\n * @param {Number} pad - The nummber of cells to add to each side (top / bottom)\n * @returns {Matrix} B - The padded matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction padVertical(A: Matrix, pad: number): Matrix {\n  const mirrored = concatVertical(A, mirrorVertical(A))\n  const height = A.height + pad * 2\n  const data = new Array(A.width * height)\n\n  for (let x = -pad; x < A.height + pad; x++) {\n    for (let y = 0; y < A.width; y++) {\n      data[(x + pad) * A.width + y] =\n        mirrored.data[mod(x, mirrored.height) * A.width + y]\n    }\n  }\n\n  return {\n    data,\n    width: A.width,\n    height,\n  }\n}\n\n/**\n * Implements `padarray` matching Matlab only for the case where:\n *\n * `padHeight <= A.height && padWidth <= A.width`\n *\n * For an input Matrix `E`, we add padding A, B, C, D, F, G, H and I of size `padHeight` and\n * `padWidth` where appropriate. For instance, given E:\n *\n * 1 2 3\n * 4 5 6\n *\n * Placed in a padding matrix like this:\n *\n * | A | B | C |\n * |---|---|---|\n * | D | E | F |\n * |---|---|---|\n * | G | H | I |\n *\n * with padding [1, 1] it becomes:\n *\n * | 1 | 1 2 3 | 3 |\n * |---|-------|---|\n * | 1 | 1 2 3 | 3 |\n * | 4 | 4 5 6 | 6 |\n * |---|-------|---|\n * | 4 | 4 5 6 | 6 |\n *\n * with padding [2, 3] it becomes:\n *\n * | 6 5 4 | 4 5 6 | 6 5 4 |\n * | 3 2 1 | 1 2 3 | 3 2 1 |\n * |-------|-------|-------|\n * | 3 2 1 | 1 2 3 | 3 2 1 |\n * | 6 5 4 | 4 5 6 | 6 5 4 |\n * |-------|-------|-------|\n * | 6 5 4 | 4 5 6 | 6 5 4 |\n * | 3 2 1 | 1 2 3 | 3 2 1 |\n *\n * @method fastPadding\n * @param {Matrix} A - The input matrix\n * @param {Array<number>} padding - An array where the first element is the padding to apply to each\n * side on each row and the second one is the vertical padding for each side of each column\n * @returns {Matrix} B - The padded matrix\n * @private\n * @memberOf matlab\n * @since 0.0.4\n */\nfunction fastPadding(\n  A: Matrix,\n  [padHeight, padWidth]: [number, number]\n): Matrix {\n  const width = A.width + padWidth * 2\n  const height = A.height + padHeight * 2\n  const data = new Array(width * height)\n\n  for (let x = -padHeight; x < 0; x++) {\n    // A\n    for (let y = -padWidth; y < 0; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(Math.abs(x) - 1) * A.width + Math.abs(y) - 1]\n    }\n    // B\n    for (let y = 0; y < A.width; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(Math.abs(x) - 1) * A.width + y]\n    }\n    // C\n    for (let y = A.width; y < A.width + padWidth; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(Math.abs(x) - 1) * A.width + 2 * A.width - y - 1]\n    }\n  }\n\n  for (let x = 0; x < A.height; x++) {\n    // D\n    for (let y = -padWidth; y < 0; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[x * A.width + Math.abs(y) - 1]\n    }\n    // E\n    for (let y = 0; y < A.width; y++) {\n      data[(x + padHeight) * width + y + padWidth] = A.data[x * A.width + y]\n    }\n    // F\n    for (let y = A.width; y < A.width + padWidth; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[x * A.width + 2 * A.width - y - 1]\n    }\n  }\n\n  for (let x = A.height; x < A.height + padHeight; x++) {\n    // G\n    for (let y = -padWidth; y < 0; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(2 * A.height - x - 1) * A.width + Math.abs(y) - 1]\n    }\n    // H\n    for (let y = 0; y < A.width; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(2 * A.height - x - 1) * A.width + y]\n    }\n    // I\n    for (let y = A.width; y < A.width + padWidth; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(2 * A.height - x - 1) * A.width + 2 * A.width - y - 1]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\nexport type PaddingValue = 'symmetric'\nexport type PaddingDirection = 'both'\n/**\n * `B = padarray(A,padsize)` pads array `A`. padsize is a vector of nonnegative integers that\n * specifies both, the amount of padding to add and the dimension along which to add it. The value\n * of an element in the vector specifies the amount of padding to add. The order of the element in\n * the vector specifies the dimension along which to add the padding.\n *\n * For example, a padsize value of `[2 3]` means add 2 elements of padding along the first dimension\n * and 3 elements of padding along the second dimension.\n *\n * By default, paddarray adds padding before the first element and after the last element along the\n * specified dimension.\n *\n * `B = padarray(A,padsize,padval)` pads array `A` where `padval` specifies the value to use as the\n * pad value. `padval` can only be 'symmetric' for this implementation of `padarray` which will pad\n * the array with mirror reflections of itself.\n *\n * This method mimics Matlab's `padarray` method with `padval = 'symmetric'` and\n * `direction = 'both'`. No other options have been implemented and, if set, they will be ignored.\n *\n * This method has been unfolded for performance and switched to simple for loops. Readability\n * suffers.\n *\n * @method padarray\n * @param {Matrix} A - The target matrix\n * @param {Array<number>} padding - An array where the first element is the padding to apply to\n * each side on each row and the second one is the vertical padding for each side of each column\n * @param {String} [padval='symmetric'] - The type of padding to apply (coerced to 'symmetric')\n * @param {String} [direction='both'] - The direction to which apply padding (coerced to 'both')\n * @returns {Matrix} c - An array with padding added on each side.\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function padarray(\n  A: Matrix,\n  [padHeight, padWidth]: [number, number],\n  _padval?: PaddingValue,\n  _direction?: PaddingDirection\n): Matrix {\n  // If the padding to mirror is not greater than `A` dimensions, we can use `fastPadding`,\n  // otherwise we fall back to a slower implementation that mimics Matlab behavior for longer\n  // matrices\n  if (A.height >= padHeight && A.width >= padWidth) {\n    return fastPadding(A, [padHeight, padWidth])\n  }\n\n  return padVertical(padHorizontal(A, padWidth), padHeight)\n}\n","import { Matrix, ImageData } from '../types'\n\n/**\n * Converts an imageData object of { width, height, data } into a 2d matrix [row, column]\n * where the value is the grayscale equivalent of the rgb input.\n *\n * This method mimics Matlab's `rgb2gray` method\n *\n * @method rgb2gray\n * @param {Matrix | ImageData} imageData - The input imageData\n * @returns {Object} grayscale - A grayscale representation of the input image\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function rgb2gray({\n  data: d,\n  width,\n  height,\n}: Matrix | ImageData): Matrix {\n  const uint8Array = new Uint8Array(width * height)\n  for (let i = 0; i < d.length; i += 4) {\n    const grayIndex = i / 4\n    /**\n     * These values are not derived from ITU's recommendation of: [0.2126,\n     * 0.7152, 0.0722] for [r, g, b] but on Matlab's implementation of [0.2989,\n     * 0.5870, 0.1140]\n     *\n     * Note that values are rounded to ensure an exact match with the original\n     * results. Rounding them would NOT lead to higher accuracy since the exact\n     * values for RGB to grayscale conversion are somewhat arbitrary (as shown\n     * by the differences between ITU and Matlab).\n     *\n     * ± 0.5 pixel differences won't be perceptible for the human eye and will\n     * have a small impact on SSIM. Based on some sample data changes were of\n     * the order of 10^-3.\n     */\n    uint8Array[grayIndex] =\n      0.29894 * d[i] + 0.58704 * d[i + 1] + 0.11402 * d[i + 2] + 0.5\n  }\n  return {\n    data: Array.from(uint8Array),\n    width,\n    height,\n  }\n}\n\nexport function rgb2grayInteger({\n  data: d,\n  width,\n  height,\n}: Matrix | ImageData): Matrix {\n  const array = new Array(width * height)\n  for (let i = 0; i < d.length; i += 4) {\n    const grayIndex = i / 4\n    array[grayIndex] = (77 * d[i] + 150 * d[i + 1] + 29 * d[i + 2] + 128) >> 8\n  }\n  return {\n    data: array,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Generates a matrix based on input `mx` but excluding items based on their modulo and their\n * position in the original matrix.\n *\n * It's a crude implementation of Matlab's `A(1:f:end,1:f:end)` syntax where the first parameter\n * is the matrix, the next one is an array describing the rows to skip [start position, every `f`\n * elements an end position] and the last one follows the same syntax for columns.\n *\n * @example\n * ```\n * img1(1:f:end,1:f:end)\n *\n * ```\n *\n * becomes:\n *\n * ```\n * skip2d(img1, [0, f, img1.length], [0, f, img1[0].length])\n * ```\n *\n * Note that the start index is 0 since, unlike Matlab's, arrays start at 0. Also, unlike in Matlab,\n * `f` must be an integer greater than or equal to 1.\n *\n * @method skip2d\n * @param {Matrix} A - The input matrix\n * @param {Array<number>} - start row, every row, end row\n * @param {Array<number>} - start col, every col, end col\n * @returns {Matrix} B - The downsized matrix\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function skip2d(\n  A: Matrix,\n  [startRow, everyRow, endRow]: [number, number, number],\n  [startCol, everyCol, endCol]: [number, number, number]\n): Matrix {\n  const width = Math.ceil((endCol - startCol) / everyCol)\n  const height = Math.ceil((endRow - startRow) / everyRow)\n  const data = new Array(width * height)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      const Ai = startRow + i * everyRow\n      const Aj = startCol + j * everyCol\n\n      data[i * width + j] = A.data[Ai * A.width + Aj]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Crops the matrix and returns a window at position `[x,y]` of size `[xlen, ylen]` from the input\n * matrix\n *\n * @method sub\n * @param {Matrix} A - The input matrix\n * @param {Number} x - The starting x offset\n * @param {Number} height - The vertical size of the window\n * @param {Number} y - The starting y offset\n * @param {Number} width - The horizontal size of the window\n * @returns {Matrix} B - The generated subwindow from matrix `c`\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function sub(\n  { data: ref, width: refWidth }: Matrix,\n  x: number,\n  height: number,\n  y: number,\n  width: number\n): Matrix {\n  const data = new Array(width * height)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      data[i * width + j] = ref[(y + i) * refWidth + x + j]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Transposes a vector or a matrix\n *\n * This method mimics Matlab's `transpose` method (which equals to the `A.'` syntax)\n *\n * `B = A.'` returns the nonconjugate transpose of A, that is, interchanges the row and column index\n * for each element.\n *\n * This method does not handle complex or imaginary numbers\n *\n * @method transpose\n * @param {Matrix} A - The matrix to transpose\n * @returns {Matrix} B - The transposed matrix\n * @public\n * @memberOf matlab\n */\nexport function transpose({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(width * height)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      data[j * height + i] = ref[i * width + j]\n    }\n  }\n\n  return {\n    data,\n    height: width,\n    width: height,\n  }\n}\n","import { Matrix } from '../types'\nimport { numbers } from './internal/numbers'\n\n/**\n * Create a matrix of all zeros\n *\n * This method mimics Matlab's `zeros` method\n *\n * @method zeros\n * @param {Number} height - The height of the matrix (rows)\n * @param {Number} [width=height] - The width of the matrix (columns)\n * @returns {Matrix} B - An n-by-m matrix of zeros\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function zeros(height: number, width: number = height): Matrix {\n  return numbers(height, width, 0)\n}\n","/* eslint-disable max-statements */\n// Exceeding max-statements to preserve the structure of the original Matlab script\nimport {\n  add2d,\n  divide2d,\n  multiply2d,\n  square2d,\n  subtract2d,\n  sum2d,\n} from './math'\nimport { filter2, fspecial } from './matlab'\nimport { Options, Matrix } from './types'\n\n/**\n * Generates a SSIM map based on two input image matrices. For images greater than 512 pixels, it\n * will downsample them.\n *\n * Images must be a 2-Dimensional grayscale image\n *\n * This method is a line-by-line port of `assets/ssim.m`. Some operations are more verbose here\n * since more logic is needed in JS to manipulate matrices than in Matlab\n *\n * Note that setting `options1.k1` and `options.k2` to 0 will generate the UQI (Universal Quality\n * Index), since it's a special case of SSIM. In general that's undesierable since `k1` and `k2`\n * contribute to the stabilization coeficients `c1` and `c2`.\n *\n * For a mathematically equivalent and more efficient implementation check `./ssim.js`.\n *\n * @method originalSsim\n * @param {Matrix} pixels1 - The reference matrix\n * @param {Matrix} pixels2 - The second matrix to compare against\n * @param {Object} options - The input options parameter\n * @returns {Matrix} ssim_map - A matrix containing the map of computed SSIMs\n * @public\n * @memberOf ssim\n * @since 0.0.2\n */\nexport function originalSsim(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  options: Options\n): Matrix {\n  let w = fspecial('gaussian', options.windowSize, 1.5)\n  const L = 2 ** options.bitDepth - 1\n  const c1 = (options.k1 * L) ** 2\n  const c2 = (options.k2 * L) ** 2\n\n  w = divide2d(w, sum2d(w))\n\n  const μ1 = filter2(w, pixels1, 'valid')\n  const μ2 = filter2(w, pixels2, 'valid')\n  const μ1Sq = square2d(μ1)\n  const μ2Sq = square2d(μ2)\n  const μ12 = multiply2d(μ1, μ2)\n  const pixels1Sq = square2d(pixels1)\n  const pixels2Sq = square2d(pixels2)\n  const σ1Sq = subtract2d(filter2(w, pixels1Sq, 'valid'), μ1Sq)\n  const σ2Sq = subtract2d(filter2(w, pixels2Sq, 'valid'), μ2Sq)\n  const σ12 = subtract2d(filter2(w, multiply2d(pixels1, pixels2), 'valid'), μ12)\n\n  if (c1 > 0 && c2 > 0) {\n    const num1 = add2d(multiply2d(μ12, 2), c1)\n    const num2 = add2d(multiply2d(σ12, 2), c2)\n    const denom1 = add2d(add2d(μ1Sq, μ2Sq), c1)\n    const denom2 = add2d(add2d(σ1Sq, σ2Sq), c2)\n\n    return divide2d(multiply2d(num1, num2), multiply2d(denom1, denom2))\n  }\n\n  const numerator1 = multiply2d(μ12, 2)\n  const numerator2 = multiply2d(σ12, 2)\n  const denominator1 = add2d(μ1Sq, μ2Sq)\n  const denominator2 = add2d(σ1Sq, σ2Sq)\n\n  return divide2d(\n    multiply2d(numerator1, numerator2),\n    multiply2d(denominator1, denominator2)\n  )\n}\n","/**\n * Implements all ssim-specific logic.\n *\n * Reproduces the original SSIM matlab scripts. For a direct comparison you may want to check the\n * scripts contained within `/assets`\n *\n * @namespace ssim\n */\nimport {\n  add2d,\n  divide2d,\n  multiply2d,\n  square2d,\n  subtract2d,\n  sum2d,\n} from './math'\nimport { conv2, normpdf, transpose } from './matlab'\nimport { Options, Matrix } from './types'\n\n/**\n * Generates a SSIM map based on two input image matrices. For images greater than 512 pixels, it\n * will downsample by default (unless `options.downsample` is set to falsy).\n *\n * Images must be a 2-Dimensional grayscale image\n *\n * This method produces the same exact output than `assets/ssim.m` when running on Matlab. It's\n * mathematically equivalent but it is not a line-by-line port. If you want a line-by-line port\n * check `originalSsim`. Several performance optimizations have been made here to achieve greater\n * performance.\n *\n * @method ssim\n * @param {Matrix} pixels1 - The reference matrix\n * @param {Matrix} pixels2 - The second matrix to compare against\n * @param {Options} options - The input options parameter\n * @returns {Matrix} ssim_map - A matrix containing the map of computed SSIMs\n * @public\n * @memberOf ssim\n */\nexport function ssim(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  options: Options\n): Matrix {\n  let w = normpdf(getRange(options.windowSize), 0, 1.5)\n  const L = 2 ** options.bitDepth - 1\n  const c1 = (options.k1 * L) ** 2\n  const c2 = (options.k2 * L) ** 2\n\n  w = divide2d(w, sum2d(w))\n  const wt = transpose(w)\n  const μ1 = conv2(pixels1, w, wt, 'valid')\n  const μ2 = conv2(pixels2, w, wt, 'valid')\n  const μ1Sq = square2d(μ1)\n  const μ2Sq = square2d(μ2)\n  const μ12 = multiply2d(μ1, μ2)\n  const pixels1Sq = square2d(pixels1)\n  const pixels2Sq = square2d(pixels2)\n  const σ1Sq = subtract2d(conv2(pixels1Sq, w, wt, 'valid'), μ1Sq)\n  const σ2Sq = subtract2d(conv2(pixels2Sq, w, wt, 'valid'), μ2Sq)\n  const σ12 = subtract2d(\n    conv2(multiply2d(pixels1, pixels2), w, wt, 'valid'),\n    μ12\n  )\n\n  if (c1 > 0 && c2 > 0) {\n    return genSSIM(μ12, σ12, μ1Sq, μ2Sq, σ1Sq, σ2Sq, c1, c2)\n  }\n  return genUQI(μ12, σ12, μ1Sq, μ2Sq, σ1Sq, σ2Sq)\n}\n\n/**\n * Generates a range of distances of size `2n+1` with increments of 1 and centered at 0.\n *\n * @example `getRange(2) => [2 1 0 1 2]\n * @method getRange\n * @param {Number} size - The maximum distance from the center\n * @returns {Matrix} out - The generated vector\n * @private\n * @memberOf ssim\n */\nfunction getRange(size: number): Matrix {\n  const offset = Math.floor(size / 2)\n  const data = new Array(offset * 2 + 1)\n\n  for (let x = -offset; x <= offset; x++) {\n    data[x + offset] = Math.abs(x)\n  }\n\n  return {\n    data,\n    width: data.length,\n    height: 1,\n  }\n}\n\n/**\n * Generates the ssim_map based on the intermediate values of the convolutions of the input with the\n * gaussian filter.\n *\n * These methods apply when K1 or K2 are not 0 (non UQI)\n *\n * @method genSSIM\n * @param {Matrix} μ12 - The cell-by cell multiplication of both images convolved\n * with the gaussian filter\n * @param {Matrix} σ12 - The convolution of cell-by cell multiplication of both\n * images minus μ12\n * @param {Matrix} μ1Sq - The convolution of image1 with the gaussian filter squared\n * @param {Matrix} μ2Sq - The convolution of image2 with the gaussian filter squared\n * @param {Matrix} σ1Sq - The convolution of image1^2, minus μ1Sq\n * @param {Matrix} σ2Sq - The convolution of image2^2, minus μ2Sq\n * @param {Number} c1 - The first stability constant\n * @param {Number} c2 - The second stability constant\n * @returns {Matrix} ssim_map - The generated map of SSIM values at each window\n * @private\n * @memberOf ssim\n */\nfunction genSSIM(\n  μ12: Matrix,\n  σ12: Matrix,\n  μ1Sq: Matrix,\n  μ2Sq: Matrix,\n  σ1Sq: Matrix,\n  σ2Sq: Matrix,\n  c1: number,\n  c2: number\n): Matrix {\n  const num1 = add2d(multiply2d(μ12, 2), c1)\n  const num2 = add2d(multiply2d(σ12, 2), c2)\n  const denom1 = add2d(add2d(μ1Sq, μ2Sq), c1)\n  const denom2 = add2d(add2d(σ1Sq, σ2Sq), c2)\n\n  return divide2d(multiply2d(num1, num2), multiply2d(denom1, denom2))\n}\n\n/**\n * Generates the Universal Quality Index (UQI) ssim_map based on the intermediate values of the\n * convolutions of the input with the gaussian filter.\n *\n * These methods apply when K1 or K2 are 0 (UQI)\n *\n * @method genUQI\n * @param {Matrix} μ12 - The cell-by cell multiplication of both images convolved\n * with the gaussian filter\n * @param {Matrix} σ12 - The convolution of cell-by cell multiplication of both\n * images minus μ12\n * @param {Matrix} μ1Sq - The convolution of image1 with the gaussian filter squared\n * @param {Matrix} μ2Sq - The convolution of image2 with the gaussian filter squared\n * @param {Matrix} σ1Sq - The convolution of image1^2, minus μ1Sq\n * @param {Matrix} σ2Sq - The convolution of image2^2, minus μ2Sq\n * @returns {Matrix} ssim_map - The generated map of SSIM values at each window\n * @private\n * @memberOf ssim\n */\nfunction genUQI(\n  μ12: Matrix,\n  σ12: Matrix,\n  μ1Sq: Matrix,\n  μ2Sq: Matrix,\n  σ1Sq: Matrix,\n  σ2Sq: Matrix\n): Matrix {\n  const numerator1 = multiply2d(μ12, 2)\n  const numerator2 = multiply2d(σ12, 2)\n  const denominator1 = add2d(μ1Sq, μ2Sq)\n  const denominator2 = add2d(σ1Sq, σ2Sq)\n\n  return divide2d(\n    multiply2d(numerator1, numerator2),\n    multiply2d(denominator1, denominator2)\n  )\n}\n","/**\n * Implements Dan Weber's ssim-specific logic.\n *\n * @namespace weberSsim\n */\nimport { ImageMatrix, MSSIMMatrix, Options } from './types'\n\nfunction edgeHandler(w: number, h: number, sumArray: any, matrixWidth: number) {\n  const rightEdge = sumArray[h * matrixWidth + w + 1]\n  const bottomEdge = sumArray[(h + 1) * matrixWidth + w]\n  const bottomRightEdge = sumArray[(h + 1) * matrixWidth + w + 1]\n  return { rightEdge, bottomEdge, bottomRightEdge }\n}\n\nexport function partialSumMatrix1(\n  pixels: ImageMatrix,\n  f: (v: number, x: number, y: number) => number\n) {\n  const { width, height, data } = pixels\n  const matrixWidth = width + 1\n  const matrixHeight = height + 1\n  const sumArray = new Int32Array(matrixWidth * matrixHeight)\n  for (let h = height - 1; h >= 0; --h) {\n    for (let w = width - 1; w >= 0; --w) {\n      const { rightEdge, bottomEdge, bottomRightEdge } = edgeHandler(\n        w,\n        h,\n        sumArray,\n        matrixWidth\n      )\n\n      sumArray[h * matrixWidth + w] =\n        f(data[h * width + w], w, h) + rightEdge + bottomEdge - bottomRightEdge\n    }\n  }\n  return { data: sumArray, height: matrixHeight, width: matrixWidth }\n}\n\nexport function partialSumMatrix2(\n  pixels1: ImageMatrix,\n  pixels2: ImageMatrix,\n  f: (a: number, b: number, x: number, y: number) => number\n) {\n  const { width, height, data: data1 } = pixels1\n  const { data: data2 } = pixels2\n  const matrixWidth = width + 1\n  const matrixHeight = height + 1\n  const sumArray = new Int32Array(matrixWidth * matrixHeight)\n  for (let h = height - 1; h >= 0; --h) {\n    for (let w = width - 1; w >= 0; --w) {\n      const { rightEdge, bottomEdge, bottomRightEdge } = edgeHandler(\n        w,\n        h,\n        sumArray,\n        matrixWidth\n      )\n      const offset = h * width + w\n      sumArray[h * matrixWidth + w] =\n        f(data1[offset], data2[offset], w, h) +\n        rightEdge +\n        bottomEdge -\n        bottomRightEdge\n    }\n  }\n  return { data: sumArray, height: matrixHeight, width: matrixWidth }\n}\n\nexport function windowMatrix(\n  sumMatrix: any,\n  windowSize: number,\n  divisor: number\n) {\n  const { width: matrixWidth, height: matrixHeight, data: sumArray } = sumMatrix\n  const imageWidth = matrixWidth - 1\n  const imageHeight = matrixHeight - 1\n  const windowWidth = imageWidth - windowSize + 1\n  const windowHeight = imageHeight - windowSize + 1\n  const windows = new Int32Array(windowWidth * windowHeight)\n  for (let h = 0; h < imageHeight; ++h) {\n    for (let w = 0; w < imageWidth; ++w) {\n      if (w < windowWidth && h < windowHeight) {\n        const sum =\n          // value at (w,h)\n          sumArray[matrixWidth * h + w] -\n          // value at (w+windowSize,h) == right side\n          sumArray[matrixWidth * h + w + windowSize] -\n          // value at (w,h+windowSize) == bottom side\n          sumArray[matrixWidth * (h + windowSize) + w] +\n          // value at (w+windowSize, h+windowSize) == bottomRight corner\n          sumArray[matrixWidth * (h + windowSize) + w + windowSize]\n\n        windows[h * windowWidth + w] = sum / divisor\n      }\n    }\n  }\n  return { height: windowHeight, width: windowWidth, data: windows }\n}\n\nexport function windowSums(pixels: ImageMatrix, windowSize: number) {\n  return windowMatrix(\n    partialSumMatrix1(pixels, (a) => a),\n    windowSize,\n    1\n  )\n}\n\nexport function windowVariance(\n  pixels: ImageMatrix,\n  sums: any,\n  windowSize: number\n) {\n  const varianceCalculation = (v: number) => v * v\n  const windowSquared = windowSize * windowSize\n  const varX = windowMatrix(\n    partialSumMatrix1(pixels, varianceCalculation),\n    windowSize,\n    1\n  )\n  for (let i = 0; i < sums.data.length; ++i) {\n    const mean = sums.data[i] / windowSquared\n    const sumSquares = varX.data[i] / windowSquared\n\n    const squareMeans = mean * mean\n    varX.data[i] = 1024 * (sumSquares - squareMeans)\n  }\n  return varX\n}\n\nexport function windowCovariance(\n  pixels1: ImageMatrix,\n  pixels2: ImageMatrix,\n  sums1: any,\n  sums2: any,\n  windowSize: number\n) {\n  const covarianceCalculation = (a: number, b: number) => a * b\n  const windowSquared = windowSize * windowSize\n  const covXY = windowMatrix(\n    partialSumMatrix2(pixels1, pixels2, covarianceCalculation),\n    windowSize,\n    1\n  )\n  for (let i = 0; i < sums1.data.length; ++i) {\n    covXY.data[i] =\n      1024 *\n      (covXY.data[i] / windowSquared -\n        (sums1.data[i] / windowSquared) * (sums2.data[i] / windowSquared))\n  }\n  return covXY\n}\n\n/**\n * Generates a SSIM map based on two input image matrices.\n * Weber SSIM is an SSIM algorithm that operates in linear time by building\n * partial sum arrays of values, variances, and covariances, making each lookup\n * performable in constant time and each variance calculation, only performed\n * once.\n *\n * Images must be a 2-Dimensional grayscale image.\n *\n * @method weberSsim\n * @param {ImageMatrix} pixels1 - The reference matrix\n * @param {ImageMatrix} pixels2 - The second matrix to compare against\n * @param {Options} options - The input options parameter\n * @returns {ImageMatrix} ssim_map - A matrix containing the map of computed\n * SSIMs\n * @public\n * @memberOf weberSsim\n */\nexport function weberSsim(\n  pixels1: ImageMatrix,\n  pixels2: ImageMatrix,\n  options: Options\n): MSSIMMatrix {\n  const { bitDepth, k1, k2, windowSize } = options\n  const L = 2 ** bitDepth - 1\n  const c1 = k1 * L * (k1 * L)\n  const c2 = k2 * L * (k2 * L)\n  const windowSquared = windowSize * windowSize\n  const pixels1Rounded = {\n    ...pixels1,\n    data: Int32Array.from(pixels1.data, (v) => v + 0.5),\n  }\n  const pixels2Rounded = {\n    ...pixels2,\n    data: Int32Array.from(pixels2.data, (v) => v + 0.5),\n  }\n  const sums1 = windowSums(pixels1Rounded, windowSize)\n  const variance1 = windowVariance(pixels1Rounded, sums1, windowSize)\n\n  const sums2 = windowSums(pixels2Rounded, windowSize)\n  const variance2 = windowVariance(pixels2Rounded, sums2, windowSize)\n  const covariance = windowCovariance(\n    pixels1Rounded,\n    pixels2Rounded,\n    sums1,\n    sums2,\n    windowSize\n  )\n  const size = sums1.data.length\n\n  let mssim = 0\n  const ssims = new Array(size)\n  for (let i = 0; i < size; ++i) {\n    const meanx = sums1.data[i] / windowSquared\n    const meany = sums2.data[i] / windowSquared\n    const varx = variance1.data[i] / 1024\n    const vary = variance2.data[i] / 1024\n    const cov = covariance.data[i] / 1024\n    const na = 2 * meanx * meany + c1\n    const nb = 2 * cov + c2\n    const da = meanx * meanx + meany * meany + c1\n    const db = varx + vary + c2\n    const ssim = (na * nb) / da / db\n    ssims[i] = ssim\n    if (i == 0) {\n      mssim = ssim\n    } else {\n      mssim = mssim + (ssim - mssim) / (i + 1)\n    }\n  }\n\n  return { data: ssims, width: sums1.width, height: sums1.height, mssim }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(607);\n","'use strict';\n\nmodule.exports = pixelmatch;\n\nconst defaultOptions = {\n    threshold: 0.1,         // matching threshold (0 to 1); smaller is more sensitive\n    includeAA: false,       // whether to skip anti-aliasing detection\n    alpha: 0.1,             // opacity of original image in diff ouput\n    aaColor: [255, 255, 0], // color of anti-aliased pixels in diff output\n    diffColor: [255, 0, 0], // color of different pixels in diff output\n    diffColorAlt: null,     // whether to detect dark on light differences between img1 and img2 and set an alternative color to differentiate between the two\n    diffMask: false         // draw the diff over a transparent background (a mask)\n};\n\nfunction pixelmatch(img1, img2, output, width, height, options) {\n\n    if (!isPixelData(img1) || !isPixelData(img2) || (output && !isPixelData(output)))\n        throw new Error('Image data: Uint8Array, Uint8ClampedArray or Buffer expected.');\n\n    if (img1.length !== img2.length || (output && output.length !== img1.length))\n        throw new Error('Image sizes do not match.');\n\n    if (img1.length !== width * height * 4) throw new Error('Image data size does not match width/height.');\n\n    options = Object.assign({}, defaultOptions, options);\n\n    // check if images are identical\n    const len = width * height;\n    const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);\n    const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);\n    let identical = true;\n\n    for (let i = 0; i < len; i++) {\n        if (a32[i] !== b32[i]) { identical = false; break; }\n    }\n    if (identical) { // fast path if identical\n        if (output && !options.diffMask) {\n            for (let i = 0; i < len; i++) drawGrayPixel(img1, 4 * i, options.alpha, output);\n        }\n        return 0;\n    }\n\n    // maximum acceptable square distance between two colors;\n    // 35215 is the maximum possible value for the YIQ difference metric\n    const maxDelta = 35215 * options.threshold * options.threshold;\n    let diff = 0;\n\n    // compare each pixel of one image against the other one\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n\n            const pos = (y * width + x) * 4;\n\n            // squared YUV distance between colors at this pixel position, negative if the img2 pixel is darker\n            const delta = colorDelta(img1, img2, pos, pos);\n\n            // the color difference is above the threshold\n            if (Math.abs(delta) > maxDelta) {\n                // check it's a real rendering difference or just anti-aliasing\n                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) ||\n                                           antialiased(img2, x, y, width, height, img1))) {\n                    // one of the pixels is anti-aliasing; draw as yellow and do not count as difference\n                    // note that we do not include such pixels in a mask\n                    if (output && !options.diffMask) drawPixel(output, pos, ...options.aaColor);\n\n                } else {\n                    // found substantial difference not caused by anti-aliasing; draw it as such\n                    if (output) {\n                        drawPixel(output, pos, ...(delta < 0 && options.diffColorAlt || options.diffColor));\n                    }\n                    diff++;\n                }\n\n            } else if (output) {\n                // pixels are similar; draw background as grayscale image blended with white\n                if (!options.diffMask) drawGrayPixel(img1, pos, options.alpha, output);\n            }\n        }\n    }\n\n    // return the number of different pixels\n    return diff;\n}\n\nfunction isPixelData(arr) {\n    // work around instanceof Uint8Array not working properly in some Jest environments\n    return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;\n}\n\n// check if a pixel is likely a part of anti-aliasing;\n// based on \"Anti-aliased Pixel and Intensity Slope Detector\" paper by V. Vysniauskas, 2009\n\nfunction antialiased(img, x1, y1, width, height, img2) {\n    const x0 = Math.max(x1 - 1, 0);\n    const y0 = Math.max(y1 - 1, 0);\n    const x2 = Math.min(x1 + 1, width - 1);\n    const y2 = Math.min(y1 + 1, height - 1);\n    const pos = (y1 * width + x1) * 4;\n    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;\n    let min = 0;\n    let max = 0;\n    let minX, minY, maxX, maxY;\n\n    // go through 8 adjacent pixels\n    for (let x = x0; x <= x2; x++) {\n        for (let y = y0; y <= y2; y++) {\n            if (x === x1 && y === y1) continue;\n\n            // brightness delta between the center pixel and adjacent one\n            const delta = colorDelta(img, img, pos, (y * width + x) * 4, true);\n\n            // count the number of equal, darker and brighter adjacent pixels\n            if (delta === 0) {\n                zeroes++;\n                // if found more than 2 equal siblings, it's definitely not anti-aliasing\n                if (zeroes > 2) return false;\n\n            // remember the darkest pixel\n            } else if (delta < min) {\n                min = delta;\n                minX = x;\n                minY = y;\n\n            // remember the brightest pixel\n            } else if (delta > max) {\n                max = delta;\n                maxX = x;\n                maxY = y;\n            }\n        }\n    }\n\n    // if there are no both darker and brighter pixels among siblings, it's not anti-aliasing\n    if (min === 0 || max === 0) return false;\n\n    // if either the darkest or the brightest pixel has 3+ equal siblings in both images\n    // (definitely not anti-aliased), this pixel is anti-aliased\n    return (hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height)) ||\n           (hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height));\n}\n\n// check if a pixel has 3+ adjacent pixels of the same color.\nfunction hasManySiblings(img, x1, y1, width, height) {\n    const x0 = Math.max(x1 - 1, 0);\n    const y0 = Math.max(y1 - 1, 0);\n    const x2 = Math.min(x1 + 1, width - 1);\n    const y2 = Math.min(y1 + 1, height - 1);\n    const pos = (y1 * width + x1) * 4;\n    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;\n\n    // go through 8 adjacent pixels\n    for (let x = x0; x <= x2; x++) {\n        for (let y = y0; y <= y2; y++) {\n            if (x === x1 && y === y1) continue;\n\n            const pos2 = (y * width + x) * 4;\n            if (img[pos] === img[pos2] &&\n                img[pos + 1] === img[pos2 + 1] &&\n                img[pos + 2] === img[pos2 + 2] &&\n                img[pos + 3] === img[pos2 + 3]) zeroes++;\n\n            if (zeroes > 2) return true;\n        }\n    }\n\n    return false;\n}\n\n// calculate color difference according to the paper \"Measuring perceived color difference\n// using YIQ NTSC transmission color space in mobile applications\" by Y. Kotsarenko and F. Ramos\n\nfunction colorDelta(img1, img2, k, m, yOnly) {\n    let r1 = img1[k + 0];\n    let g1 = img1[k + 1];\n    let b1 = img1[k + 2];\n    let a1 = img1[k + 3];\n\n    let r2 = img2[m + 0];\n    let g2 = img2[m + 1];\n    let b2 = img2[m + 2];\n    let a2 = img2[m + 3];\n\n    if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2) return 0;\n\n    if (a1 < 255) {\n        a1 /= 255;\n        r1 = blend(r1, a1);\n        g1 = blend(g1, a1);\n        b1 = blend(b1, a1);\n    }\n\n    if (a2 < 255) {\n        a2 /= 255;\n        r2 = blend(r2, a2);\n        g2 = blend(g2, a2);\n        b2 = blend(b2, a2);\n    }\n\n    const y1 = rgb2y(r1, g1, b1);\n    const y2 = rgb2y(r2, g2, b2);\n    const y = y1 - y2;\n\n    if (yOnly) return y; // brightness difference only\n\n    const i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);\n    const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);\n\n    const delta = 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;\n\n    // encode whether the pixel lightens or darkens in the sign\n    return y1 > y2 ? -delta : delta;\n}\n\nfunction rgb2y(r, g, b) { return r * 0.29889531 + g * 0.58662247 + b * 0.11448223; }\nfunction rgb2i(r, g, b) { return r * 0.59597799 - g * 0.27417610 - b * 0.32180189; }\nfunction rgb2q(r, g, b) { return r * 0.21147017 - g * 0.52261711 + b * 0.31114694; }\n\n// blend semi-transparent color with white\nfunction blend(c, a) {\n    return 255 + (c - 255) * a;\n}\n\nfunction drawPixel(output, pos, r, g, b) {\n    output[pos + 0] = r;\n    output[pos + 1] = g;\n    output[pos + 2] = b;\n    output[pos + 3] = 255;\n}\n\nfunction drawGrayPixel(img, i, alpha, output) {\n    const r = img[i + 0];\n    const g = img[i + 1];\n    const b = img[i + 2];\n    const val = blend(rgb2y(r, g, b), alpha * img[i + 3] / 255);\n    drawPixel(output, i, val, val, val);\n}\n","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { Context } from \"vm\";\r\n\r\nexport interface Rect {\r\n    x: number;\r\n    y: number;\r\n    w: number;\r\n    h: number;\r\n    color: number[];\r\n}\r\n\r\nexport interface Vertex {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport interface Polygon {\r\n    vertices: Vertex[];\r\n    color: number[];\r\n}\r\n\r\nexport interface Image {\r\n    image: ImageData|null;\r\n    renderedWidth: number;\r\n    renderedHeight: number;\r\n    offscreenWidth: number;\r\n    offscreenHeight: number;\r\n    ratioOffscreenWidth: number; // ratio to limit\r\n    ratioOffscreenHeight: number; // ratio to limit\r\n    limitOffscreen: number;\r\n}\r\n\r\nexport function getRGBAFromColor(c: number[]): string {\r\n    let color = \"rgb(0, 0, 0\";\r\n    if (c.length === 3) {\r\n        color = `rgb(${c[0]},${c[1]},${c[2]})`;\r\n    }\r\n    else {\r\n        color = `rgba(${c[0]},${c[1]},${c[2]},${c[3]})`\r\n    }\r\n    return color;\r\n}\r\n\r\nexport function drawRectangle(ctx: Context, rect: Rect) {\r\n    if (!ctx ) {\r\n        return;\r\n    }\r\n\r\n    ctx.fillStyle =  getRGBAFromColor(rect.color);;\r\n    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);\r\n}\r\n\r\nexport function drawPolygon(ctx: Context, polygon: Polygon) {\r\n    if (!ctx || polygon.vertices.length === 0) {\r\n        return;\r\n    }\r\n\r\n    ctx.fillStyle = getRGBAFromColor(polygon.color);\r\n    ctx.beginPath();\r\n\r\n    let vertex = polygon.vertices[0];\r\n    ctx.moveTo(vertex.x, vertex.y);\r\n    for(let i = 1; i < polygon.vertices.length; i++) {\r\n        vertex = polygon.vertices[i];\r\n        ctx.lineTo(vertex.x, vertex.y);\r\n    }\r\n\r\n    ctx.closePath();\r\n    ctx.fill();\r\n}\r\n\r\nexport function moveVertex(v: Vertex, range: number, width: number, height: number): Vertex {\r\n    const direction = Math.random() * 2 * Math.PI;\r\n    const distance = Math.random() * range;\r\n\r\n    let x = v.x + Math.floor(Math.cos(direction) * distance);\r\n    x = Math.max(0, Math.min(x, width));\r\n\r\n    let y = v.y + Math.floor(Math.sin(direction) * distance);\r\n    y = Math.max(0, Math.min(y, height));\r\n\r\n    const movedVertex: Vertex = {\r\n        x: x,\r\n        y: y\r\n    };\r\n\r\n    return movedVertex; \r\n  };\r\n\r\n  export function copyPolygon(p: Polygon): Polygon {\r\n      const vertices: Vertex[] = [];\r\n      p.vertices.forEach((vertex: Vertex) => {\r\n          let v = {...vertex};\r\n          vertices.push(v);\r\n      });\r\n\r\n      const polygon = {\r\n          vertices: vertices,\r\n          color: [...p.color]\r\n      };\r\n\r\n      return polygon;\r\n  }\r\n\r\n export function getLimitDimensions(width: number, height: number, limit?: number): {width: number, height: number, ratio: number} {\r\n    const ratioImage = height / width;\r\n    if (limit && (width >= limit || height >= limit)) {        \r\n        if (ratioImage > 1) {\r\n            return { width: Math.round(limit / ratioImage), height: limit, ratio: ratioImage };\r\n        }\r\n        else {\r\n            return { width: limit, height: Math.round(limit * ratioImage), ratio: ratioImage};\r\n        }\r\n        \r\n    }\r\n    return { width: width, height: height, ratio: ratioImage};\r\n}","import { Polygon, Vertex } from \"./geometry\";\r\n\r\nexport interface Individual {\r\n    genes: number[];\r\n    fitness: number;\r\n    ssim: number;\r\n    pixelDiff: number;\r\n    diff: ImageData | undefined;\r\n    probability: number;\r\n    id: number\r\n    phenotype: Polygon[];\r\n}\r\n\r\nexport interface Result {\r\n    fitness: number;\r\n    ssim: number;\r\n    pixelDiff: number;\r\n    diff: ImageData | undefined;\r\n}\r\n\r\nexport interface Configuration {\r\n    population: number;\r\n    selectCutoff: number;\r\n    keepPreviousRatio: number;\r\n    newIndividualRatio: number;\r\n    crossoverParentRatio: number;\r\n    mutationRate: number;\r\n    vertexMovement: number;\r\n    colorModificationRate: number;\r\n    enableSsim: boolean;\r\n    enablePixelDiff: boolean;\r\n    ratioSsim: number;\r\n    ratioPixelDiff: number;\r\n    enableTransparency: boolean;\r\n    nbVertex: number;\r\n    nbPolygons: number;\r\n    // Maybe to add later in configuration\r\n    //selectParentMode //tournament / fortune wheel\r\n    //crossOVeMode //by polygone / vertex / coordinate\r\n}\r\n\r\n\r\nexport function createEmptyIndividual(): Individual {\r\n    const ind: Individual = {\r\n        id: 0,\r\n        genes: [],\r\n        fitness: 0,\r\n        ssim: 0,\r\n        pixelDiff: 0,\r\n        diff: undefined,\r\n        probability: 0,\r\n        phenotype: []\r\n    }\r\n\r\n    return ind;\r\n}\r\n\r\nexport function createIndividual(nbPolygons: number, nbVertices: number, nbColor: number, width: number, height: number): Individual {\r\n    const genes: number[] = [];\r\n    for (let i = 0; i < nbPolygons; i++) {\r\n        \r\n        const x = randomNumberInRange(0, width, true);\r\n        const y = randomNumberInRange(0, height, true);\r\n\r\n        for (let j = 0; j < nbVertices; j++) {\r\n            genes.push(x + randomNumberInRange(0, width / 2, true));\r\n            genes.push(y + randomNumberInRange(0, height / 2, true));\r\n        }\r\n\r\n        for (let j = 0; j < nbColor; j++) {\r\n            const c = j < 3 ? randomNumberInRange(0, 256, true) : randomNumberInRange(0.2, 1, false);\r\n            genes.push(c); \r\n        }        \r\n    }\r\n   \r\n    const ind: Individual = {\r\n        id: Date.now(),\r\n        genes: genes,\r\n        fitness: 0,\r\n        ssim: 0,\r\n        pixelDiff: 0,\r\n        diff: undefined,\r\n        probability: 0,\r\n        phenotype: []\r\n    }\r\n\r\n    return ind;\r\n}\r\n\r\nexport function generatePopulation(popSize: number, genesSize: number, nbVertices: number, nbColor: number, width: number, height: number): Individual[]\r\n{\r\n    let population = [];\r\n    for (let i = 0; i < popSize; i++) {\r\n        const ind = createIndividual( genesSize, nbVertices, nbColor, width, height);\r\n        population.push(ind);\r\n    }\r\n    return population;\r\n}\r\n\r\nexport function randomNumberInRange(min: number, max: number, isInteger: boolean): number {\r\n    let value = Math.random() * (max - min) + min;\r\n\r\n    if (isInteger) {\r\n        value = Math.floor(value);\r\n    }\r\n    else {\r\n        value = Math.round(value * 1000.0) / 1000.0; // force 3 digits max\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nexport function buildPhenotypeFromGenes(genes: number[], nbVertices: number, nbColor: number):  Polygon[] {\r\n    const phenotype: Polygon[] = [];\r\n\r\n    const polygonSize = nbVertices * 2 + nbColor;\r\n    for (let i = 0; i < genes.length; i = i+polygonSize) {\r\n        const p: Polygon = {\r\n            vertices: [],\r\n            color: []\r\n        };\r\n\r\n        const nbCoordinates = nbVertices * 2;\r\n        for (let j = 0; j < nbCoordinates; j = j+2) {\r\n            const v: Vertex = {\r\n                x: genes[i + j],\r\n                y: genes[i + j + 1]\r\n            };\r\n            p.vertices.push(v);    \r\n        }\r\n\r\n        for (let k = 0; k < nbColor; k++) {\r\n            p.color.push(genes[i + nbCoordinates + k]);    \r\n        }\r\n        phenotype.push(p);\r\n    }\r\n    return phenotype;\r\n}\r\n\r\nexport function sortDescByFitness(population: Individual[]): Individual[] {\r\n    const sortFn = (a: Individual, b: Individual): number => {\r\n        return b.fitness - a.fitness;\r\n    };\r\n\r\n    return [...population].sort(sortFn);\r\n}\r\n\r\nexport function sortDescByProbability(population: Individual[]): Individual[] {\r\n    const sortFn = (a: Individual, b: Individual): number => {\r\n        return a.probability - b.probability;\r\n    };\r\n\r\n    return [...population].sort(sortFn);\r\n}\r\n\r\nexport function convertFitnessIntoProbabilities(population: Individual[]): Individual[] {\r\n    let sumFit = 0.0;\r\n    let scores = [];\r\n    let populationWithProba = [...population];\r\n\r\n    for (let ind of population) {\r\n        const fitness = ind.fitness * ind.fitness;\r\n        scores.push(fitness);\r\n        sumFit += fitness;\r\n    }\r\n\r\n    let previousProba = 0.0;\r\n    for (let i = 0; i < scores.length; i++) {\r\n        const relativeFitness = scores[i] / sumFit;\r\n        previousProba += relativeFitness;\r\n        populationWithProba[i].probability = previousProba; // cumulation of probabilities for fortune of wheel\r\n    }\r\n\r\n    // Round last probability to 1\r\n    const lastIndex = populationWithProba.length - 1;\r\n    populationWithProba[lastIndex].probability = 1.0;\r\n    return populationWithProba;\r\n}\r\n\r\nexport function pickParent(population: Individual[]): Individual {\r\n    const rand = Math.random();\r\n    let i = 0;\r\n    while (i < population.length && population[i].probability <= rand) {\r\n        i++;\r\n    }\r\n\r\n    if (i === population.length) {\r\n        i = i - 1;\r\n    }\r\n    return population[i];\r\n}\r\n\r\nexport function generateTournamentPool(population: Individual[], poolSize: number): Individual[] {\r\n    const pool: Individual[] = [];\r\n    for (let i = 0; i < poolSize; i++) {\r\n        const candidate = pickParent(population);\r\n        pool.push(candidate);\r\n    }\r\n    return pool;\r\n}\r\n\r\nexport function pickParentFromTournament(population: Individual[], tournamentSize: number): Individual {\r\n    let best: Individual = createEmptyIndividual();\r\n    for (let i = 0; i < tournamentSize; i++) {\r\n        const index = Math.floor(Math.random() * population.length);\r\n        const candidate = population[index];\r\n        if (best.id === 0 || candidate.fitness > best.fitness) {\r\n            best = candidate;\r\n        }\r\n    }\r\n    return best;\r\n}\r\n\r\n// Crossover with single point crossover\r\n/*\r\nfunction crossOver(a: Individual, b: Individual, nbVertices: number, nbColor: number): Individual {\r\n    const child: Individual = {\r\n        genes: [],\r\n        fitness: 0,\r\n        ssim: 0,\r\n        pixelDiff: 0,\r\n        diff: undefined,\r\n        probability: 0,\r\n        id: Date.now(),\r\n        phenotype: []\r\n    };\r\n\r\n    let ratio = 0.6;\r\n    const polygonSize = (nbVertices * 2 + nbColor);\r\n    const nbPolygons = nbVertices / polygonSize;\r\n    const splitIndex = Math.floor(nbPolygons * ratio) * polygonSize;\r\n    const primaryGenes = a.fitness > b.fitness ? a.genes : b.genes;\r\n    const secdondatyGenes = a.fitness > b.fitness ? b.genes : a.genes;\r\n\r\n    child.genes = child.genes.concat(primaryGenes.slice(0, splitIndex));\r\n    child.genes = child.genes.concat(secdondatyGenes.slice(splitIndex));\r\n\r\n    return child;\r\n}\r\n*/\r\n\r\n// Crossover on polygon granularity\r\nexport function crossOver(a: Individual, b: Individual, parentRatio: number, nbVertices: number, nbColor: number): Individual {\r\n    const child: Individual = {\r\n        genes: [],\r\n        fitness: 0,\r\n        ssim: 0,\r\n        pixelDiff: 0,\r\n        diff: undefined,\r\n        probability: 0,\r\n        id: Date.now(),\r\n        phenotype: []\r\n    };\r\n\r\n    let probaToPickFromA = (a.fitness > b.fitness) ? 0.6 : ((a.fitness === b.fitness)  ? parentRatio : 1 - parentRatio);\r\n   \r\n    let i = 0;\r\n    while (i < a.genes.length) {\r\n        const polygonSize = (nbVertices * 2 + nbColor);\r\n        let genes = Math.random() < probaToPickFromA ? a.genes : b.genes;\r\n        child.genes = child.genes.concat(genes.slice(i, i + polygonSize));\r\n        i += polygonSize;\r\n    }\r\n\r\n    return child;\r\n}\r\n\r\n/*\r\n// Crossover on vertex granularity\r\nexport function crossOver(a: Individual, b: Individual, parentRatio: number, nbVertices: number, nbColor: number): Individual {\r\n    const child: Individual = {\r\n        genes: [],\r\n        fitness: 0,\r\n        ssim: 0,\r\n        pixelDiff: 0,\r\n        diff: undefined,\r\n        probability: 0,\r\n        id: Date.now(),\r\n        phenotype: []\r\n    };\r\n\r\n    let probaToPickFromA = (a.fitness > b.fitness) ? 0.6 : ((a.fitness === b.fitness)  ? parentRatio : 1 - parentRatio);\r\n    \r\n    let i = 0;\r\n    while (i < a.genes.length) {        \r\n        const relativeIndex = i % (nbVertices * 2 + nbColor); \r\n        const isVertex = relativeIndex < (nbVertices * 2);\r\n        if (isVertex) {\r\n            // Copy vertex\r\n            let genes = Math.random() < probaToPickFromA ? a.genes : b.genes;\r\n            let v: Vertex = {\r\n                x: genes[i],\r\n                y: genes[i + 1]\r\n            };\r\n                            \r\n            child.genes.push(v.x);\r\n            child.genes.push(v.y);\r\n            i += 2;\r\n        }\r\n        else {\r\n            // Copy color\r\n            let genes = Math.random() < probaToPickFromA ? a.genes : b.genes;\r\n            child.genes.push(genes[i]);\r\n            child.genes.push(genes[i+1]);\r\n            child.genes.push(genes[i+2]);\r\n            i += 3;\r\n            \r\n            const hasAlpha = nbColor === 4;\r\n            if (hasAlpha) {\r\n                child.genes.push(genes[i]);\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    return child;\r\n}\r\n*/\r\n\r\n/*\r\n// Granularity of each gene\r\nexport function crossOver(a: Individual, b: Individual, parentRatio: number, nbVertices: number, nbColor: number): Individual {\r\n    const child: Individual = {\r\n        genes: [],\r\n        fitness: 0,\r\n        ssim: 0,\r\n        pixelDiff: 0,\r\n        diff: undefined,\r\n        probability: 0,\r\n        id: Date.now(),\r\n        phenotype: []\r\n    };\r\n\r\n    let probaToPickFromA = (a.fitness > b.fitness) ? 0.6 : ((a.fitness === b.fitness)  ? parentRatio : 1 - parentRatio);\r\n\r\n    let i = 0;\r\n    while (i < a.genes.length) {        \r\n        let genes = Math.random() < probaToPickFromA ? a.genes : b.genes;\r\n        child.genes.push(genes[i]);\r\n        i++;\r\n    }\r\n\r\n    return child;\r\n}\r\n*/\r\n","import unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import ssim, { Options } from \"ssim.js\";\r\nimport pixelmatch from \"pixelmatch\";\r\nimport {drawPolygon, moveVertex, Vertex} from \"./common/geometry\";\r\nimport {AGworkerIn, AGworkerOut} from \"./common/communication\";\r\nimport {buildPhenotypeFromGenes, Individual, randomNumberInRange, generateTournamentPool,\r\n    Result, generatePopulation, convertFitnessIntoProbabilities, sortDescByProbability, createIndividual,\r\n    pickParent, pickParentFromTournament, sortDescByFitness, crossOver} from \"./common/ga\";\r\nimport { Context } from \"vm\";\r\n\r\ndeclare const self: Worker;\r\nexport default {} as typeof Worker & { new (): Worker };\r\n\r\nfunction evaluatePopulation(population: Individual[], enableSsim: boolean, enablePixelDiff: boolean, ratioSsim: number, ratioPixelDiff: number, nbVertices: number, nbColor: number, originalImage: ImageData, ctx: Context): Individual[] {\r\n    if(!ctx) {\r\n        return [...population];\r\n    }\r\n\r\n    let evaluatedPopulation = [];\r\n    for (let i = 0; i < population.length; i++) {        \r\n        // Draw the image from the genes\r\n        const ind = population[i];\r\n        const result = evaluate(ind, enableSsim, enablePixelDiff, ratioSsim, ratioPixelDiff, nbVertices, nbColor, originalImage, ctx);\r\n        \r\n        const evaluatedInd: Individual = {\r\n            genes: [...ind.genes],\r\n            fitness: result.fitness,\r\n            ssim: result.ssim,\r\n            pixelDiff: result.pixelDiff,\r\n            diff: result.diff,\r\n            probability: 0,\r\n            id: ind.id,\r\n            phenotype: [...ind.phenotype]\r\n        };\r\n\r\n        evaluatedPopulation.push(evaluatedInd);\r\n    }\r\n\r\n    return evaluatedPopulation;\r\n}\r\n\r\nfunction evaluate(ind: Individual, enableSsim: boolean, enablePixelDiff: boolean, ratioSsim: number, ratioPixelDiff: number, nbVertices: number, nbColor: number, image: ImageData, ctx: Context): Result {\r\n    \r\n    ind.phenotype = buildPhenotypeFromGenes(ind.genes, nbVertices, nbColor);\r\n    \r\n    // Clean the drawing space\r\n    ctx.clearRect(0, 0, image.width, image.height);\r\n    ctx.fillStyle = \"#000000\";\r\n    ctx.fillRect(0, 0, image.width, image.height);\r\n    \r\n    // Draw the image from the genes\r\n    for (let i = 0; i < ind.phenotype.length; i++) {\r\n        const shape = ind.phenotype[i];\r\n        drawPolygon(ctx, shape);\r\n    }\r\n    const generatedImage = ctx.getImageData(0, 0, image.width, image.height);\r\n\r\n    // Compute similarity\r\n    let ssimResult = {\r\n        mssim: 0\r\n    };\r\n\r\n    let overloadRatioSsim = ratioSsim;\r\n    if (enableSsim) {\r\n        const options: Options = {\r\n            rgb2grayVersion: 'original',\r\n            windowSize: 11, // window size for the SSIM map\r\n            k1: 0.01, //The first stability constant\r\n            k2: 0.03, //The second stability constant\r\n            bitDepth: 8, //The number of bits used to encode each pixel\r\n            downsample: 'original', //false / 'original' / 'fast'\r\n            ssim: 'weber'\r\n        };\r\n        ssimResult = ssim(image, generatedImage, options);\r\n    }\r\n    else {\r\n        overloadRatioSsim= 0;\r\n    }\r\n\r\n    let diff: ImageData | undefined = undefined;\r\n    let ratioMatchingPixel= 0;\r\n    let overloadRatioPixelDiff = ratioPixelDiff;\r\n    if (enablePixelDiff){\r\n        const canvas = new OffscreenCanvas(image.width, image.height);\r\n        const diffContext = canvas.getContext('2d');\r\n        let nbPixelsDiff = 0;\r\n        if (diffContext) {\r\n            diff = diffContext.createImageData(image.width, image.height);\r\n            nbPixelsDiff = pixelmatch(image.data, generatedImage.data, diff.data, image.width, image.height, {threshold: 0.1});\r\n        }\r\n        \r\n        ratioMatchingPixel = ((image.width * image.height) - nbPixelsDiff) / (image.width * image.height);\r\n    }\r\n    else {\r\n        overloadRatioPixelDiff = 0;\r\n    }\r\n    \r\n    const result: Result = {\r\n        fitness: (ssimResult.mssim * overloadRatioSsim + ratioMatchingPixel * overloadRatioPixelDiff) / (overloadRatioSsim + overloadRatioPixelDiff),\r\n        ssim: ssimResult.mssim,\r\n        pixelDiff: ratioMatchingPixel,\r\n        diff: diff\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction mutate(ind: Individual, mutationRate: number, vertexMovement: number, colorModificationRate: number, nbVertices: number, nbColor: number, width: number, height: number, force: boolean): Individual {\r\n    const mutant: Individual = {\r\n        genes: [],\r\n        fitness: 0,\r\n        ssim: 0,\r\n        pixelDiff: 0,\r\n        diff: undefined,\r\n        probability: 0,\r\n        id: Date.now(),\r\n        phenotype: []\r\n    };\r\n    \r\n    const probaToMutate = force ? 1.0 : mutationRate;\r\n    let i = 0;\r\n    let swapBuffer: number[] = [];\r\n    const polygonSize = nbVertices * 2 + nbColor;\r\n    while (i < ind.genes.length) {\r\n        if (Math.random() < probaToMutate) {     \r\n            const relativeIndex = i % polygonSize;   \r\n            const isStartingOfAPolygon = relativeIndex === 0;\r\n\r\n            // debugger; \r\n\r\n            if (Math.random() < 0.1 && isStartingOfAPolygon) {\r\n                 // move polygon at the end for rendering\r\n                swapBuffer = swapBuffer.concat(ind.genes.slice(i, i + polygonSize));\r\n                i += polygonSize;\r\n            }\r\n            else {\r\n                // Modifiy polygon shape and color                  \r\n                const isVertexCoordinates = relativeIndex < (nbVertices * 2);               \r\n                const isStartingVertex = (relativeIndex % 2) === 0 && isVertexCoordinates;\r\n                const isColorInformation = relativeIndex >= (nbVertices * 2);\r\n\r\n                if (isStartingVertex) {\r\n                    //Modify the vertex\r\n                    let v: Vertex = {\r\n                        x: ind.genes[i],\r\n                        y: ind.genes[i + 1]\r\n                    };\r\n                                    \r\n                    let range = randomNumberInRange(-vertexMovement, vertexMovement, false);\r\n                    if (range > -1 && range <= 0) { range = -1}\r\n                    if (range < 1 && range >= 0) { range = 1}\r\n                    v = moveVertex(v, range, width, height);\r\n                    mutant.genes.push(v.x);\r\n                    mutant.genes.push(v.y);\r\n                    i += 2;\r\n                }\r\n                else if (isColorInformation) {\r\n                    // Change color\r\n                    const range = randomNumberInRange(-colorModificationRate, colorModificationRate, false);\r\n                    let c = ind.genes[i] + ind.genes[i] * range;\r\n                    const isAlpha = nbColor === 4 && (relativeIndex === (polygonSize - 1));\r\n                    if (isAlpha) {\r\n                        c = Math.max(0, Math.min(c, 1));\r\n                    }\r\n                    else {\r\n                        c = Math.round(c);\r\n                        c = Math.max(0.2, Math.min(c, 255));\r\n                    }\r\n                    mutant.genes.push(c);\r\n                    i++;\r\n                }\r\n                else {\r\n                    //y coordinate of a vertex do nothing to mutate it\r\n                    mutant.genes.push(ind.genes[i]);\r\n                    i++;\r\n                }\r\n            }         \r\n        }\r\n        else {\r\n            mutant.genes.push(ind.genes[i]);\r\n            i++;\r\n        }      \r\n    }    \r\n    mutant.genes = mutant.genes.concat(swapBuffer);\r\n    return mutant;\r\n}\r\n\r\nself.addEventListener(\"message\", e => {\r\n    if (!e) return;\r\n    \r\n    const msg: AGworkerIn = e.data as AGworkerIn;\r\n\r\n    const config = msg.configuration;\r\n    const nbColors = config.enableTransparency ? 4 : 3;\r\n    \r\n    let previousPop = msg.population;\r\n    let previousBest = msg.best;\r\n    const originalImage = msg.image;\r\n\r\n    // Create ressources to draw the generated images\r\n    const canvas = new OffscreenCanvas(msg.renderingWidth, msg.renderingHeight);\r\n    const ctx = canvas.getContext('2d');\r\n    \r\n    const canvasOriginal = new OffscreenCanvas(msg.renderingWidth, msg.renderingHeight);\r\n    const ctxOriginal = canvasOriginal.getContext('2d');  \r\n\r\n    if(!ctx || !ctxOriginal) {\r\n        console.error(\"no ctx to draw the image\");\r\n\r\n        const response: AGworkerOut = {\r\n            isRunning: true,\r\n            best: previousBest,\r\n            population: [...previousPop],\r\n            generation: msg.generation,\r\n            elapsedTime: 0,\r\n            notImprovingSince: 0\r\n        };\r\n\r\n        postMessage(response);\r\n    }\r\n    else {\r\n        ctxOriginal.putImageData(originalImage, 0, 0);\r\n        const scaledOriginalImage = ctxOriginal.getImageData(0, 0, msg.renderingWidth, msg.renderingHeight);\r\n\r\n        let nextPop: Individual[] = [];        \r\n        let start = (new Date()).getTime();\r\n        if (previousPop.length === 0) {\r\n            nextPop = generatePopulation(config.population, config.nbPolygons, config.nbVertex, nbColors, msg.renderingWidth, msg.renderingHeight);\r\n            nextPop = evaluatePopulation(\r\n                nextPop, \r\n                config.enableSsim,\r\n                config.enablePixelDiff,\r\n                config.ratioSsim,\r\n                config.ratioPixelDiff,\r\n                config.nbVertex,\r\n                nbColors,\r\n                scaledOriginalImage,\r\n                ctx);                    \r\n        }\r\n        else {\r\n            if (previousBest.id !== previousPop[0].id) {\r\n                previousPop = convertFitnessIntoProbabilities([...previousPop, previousBest]);\r\n            }                        \r\n            previousPop = sortDescByProbability(previousPop);\r\n\r\n            const poolSize = Math.round(previousPop.length * config.selectCutoff);\r\n            const tournamentPool = generateTournamentPool(previousPop, poolSize);\r\n\r\n            for (let i = 0; i < config.population; i++) {\r\n                const rand = Math.random();\r\n                if (rand < 0.1) {\r\n                    // Add an previous individual that may be mutated\r\n                    const happySelectInd = pickParent(previousPop);\r\n                    const mutant: Individual = mutate(\r\n                        happySelectInd, \r\n                        config.mutationRate, \r\n                        config.vertexMovement, \r\n                        config.colorModificationRate, \r\n                        config.nbVertex, \r\n                        nbColors, \r\n                        msg.renderingWidth, \r\n                        msg.renderingHeight, \r\n                        false);\r\n\r\n                    const result = evaluate(\r\n                        mutant, \r\n                        config.enableSsim,\r\n                        config.enablePixelDiff,\r\n                        config.ratioSsim,\r\n                        config.ratioPixelDiff,\r\n                        config.nbVertex,\r\n                        nbColors,\r\n                        scaledOriginalImage, \r\n                        ctx);                \r\n\r\n                    mutant.fitness = result.fitness;\r\n                    mutant.ssim = result.ssim;\r\n                    mutant.pixelDiff = result.pixelDiff;\r\n                    mutant.diff = result.diff;\r\n                    nextPop.push(mutant);\r\n                }\r\n                else if (rand < 0.2) {\r\n                    // Create a new individual\r\n                    const ind = createIndividual(config.nbPolygons, config.nbVertex, nbColors, msg.renderingWidth, msg.renderingHeight);\r\n                    const result = evaluate(\r\n                        ind, \r\n                        config.enableSsim,\r\n                        config.enablePixelDiff,\r\n                        config.ratioSsim,\r\n                        config.ratioPixelDiff,\r\n                        config.nbVertex,\r\n                        nbColors,\r\n                        scaledOriginalImage, \r\n                        ctx);\r\n\r\n                    ind.fitness = result.fitness;\r\n                    ind.ssim = result.ssim;\r\n                    ind.pixelDiff = result.pixelDiff;\r\n                    ind.diff = result.diff;\r\n                    nextPop.push(ind);\r\n                }\r\n                else {\r\n                    // Create a child\r\n                    // const parentA = pickParent(previousPop);\r\n                    // const parentB = pickParent(previousPop);\r\n                    const parentA = pickParentFromTournament(tournamentPool, 3);\r\n                    const parentB = pickParentFromTournament(tournamentPool, 3);                    \r\n                    let child = crossOver(parentA, parentB, config.crossoverParentRatio, config.nbVertex, nbColors);\r\n                    child = mutate(\r\n                        child, \r\n                        config.mutationRate, \r\n                        config.vertexMovement, \r\n                        config.colorModificationRate, \r\n                        config.nbVertex, \r\n                        nbColors, \r\n                        msg.renderingWidth, \r\n                        msg.renderingHeight, \r\n                        false);\r\n\r\n                    const result = evaluate(\r\n                        child, \r\n                        config.enableSsim,\r\n                        config.enablePixelDiff,\r\n                        config.ratioSsim,\r\n                        config.ratioPixelDiff,\r\n                        config.nbVertex,\r\n                        nbColors,\r\n                        scaledOriginalImage, \r\n                        ctx);\r\n\r\n                    child.fitness = result.fitness;\r\n                    child.ssim = result.ssim;\r\n                    child.pixelDiff = result.pixelDiff;\r\n                    child.diff = result.diff;\r\n                    nextPop.push(child);\r\n                }\r\n            }            \r\n        }\r\n            \r\n        nextPop = sortDescByFitness(nextPop);\r\n        \r\n        let end = (new Date()).getTime();\r\n        let elapsedTime = (end - start) / 1000; //in seconds\r\n\r\n        let best: Individual;\r\n        let nonImprovingSince = msg.notImprovingSince;\r\n        if (previousBest && previousBest.fitness > nextPop[0].fitness) {\r\n            best = previousBest;\r\n            nonImprovingSince++;\r\n        }\r\n        else {\r\n            best = nextPop[0];\r\n            nonImprovingSince = 0;\r\n        }\r\n        \r\n        const response: AGworkerOut = {\r\n            isRunning: true,\r\n            best: best,\r\n            population: nextPop,\r\n            generation: msg.generation + 1,\r\n            elapsedTime: elapsedTime,\r\n            notImprovingSince: nonImprovingSince\r\n        };\r\n    \r\n        postMessage(response);\r\n    }\r\n});"],"sourceRoot":""}